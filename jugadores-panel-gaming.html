<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="panel-type" content="PJG">
    <meta name="header-container" content="header-container">
    <title>Panel Jugador - PLAYTEST</title>
    
    <!-- Estilos del header unificado -->
    <link rel="stylesheet" href="header-styles.css">
    <script src="header-loader.js"></script>
    <script src="api-data-service.js"></script>
    <script src="bloques-creados-component.js"></script>
    
    <!-- CDN de React y Babel para compatibilidad con el código de index.html -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Anular header original de index.html */
        .original-header,
        .index-header,
        header.bg-brand-secondary {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            overflow: hidden !important;
        }

        /* Estilos adicionales para el panel */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0D1B2A;
            min-height: 100vh;
            color: #E0E1DD;
            padding-top: 100px; /* Espacio para header unificado */
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Variables CSS para compatibilidad con Tailwind */
        :root {
            --brand-primary: #0D1B2A;
            --brand-secondary: #1B263B;
            --brand-tertiary: #415A77;
            --brand-accent: #778DA9;
            --brand-light: #E0E1DD;
            --brand-cta: #3B82F6;
            --brand-cta-hover: #2563EB;
            --brand-success: #10B981;
            --brand-danger: #EF4444;
        }

        /* Panel Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 1px solid #415A77;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: #E0E1DD;
            margin: 0;
        }

        /* Tabs Styles */
        .tabs-container {
            background: #1B263B;
            border: 1px solid #415A77;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .tabs-nav {
            display: flex;
            border-bottom: 1px solid #415A77;
            overflow-x: auto;
        }

        .tab-button {
            flex: none;
            padding: 15px 25px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #778DA9;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: fit-content;
        }

        .tab-button.active {
            color: #E0E1DD;
            background: #415A77;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .tab-button:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #3B82F6;
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        /* Section Styles */
        .section {
            background: #1B263B;
            border: 1px solid #415A77;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .section-title {
            background: #415A77;
            color: #E0E1DD;
            padding: 15px 20px;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            border-radius: 10px 10px 0 0;
            border-bottom: 1px solid #778DA9;
        }

        .section-content {
            padding: 20px;
        }

        /* Search Input */
        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #415A77;
            border-radius: 6px;
            background: #0D1B2A;
            color: #E0E1DD;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
    </style>
</head>
<body>
    <!-- Contenedor del header unificado -->
    <div id="header-container"></div>

    <!-- Contenido principal del panel de jugadores -->
    <div class="container">
        <div class="header">
            <p>Plataforma completa para jugar, gestionar bloques de contenido y revisar tu progreso académico.</p>
        </div>

        <div class="tabs-container">
            <div class="tabs-nav">
                <button class="tab-button active" onclick="switchTab('partidas')">🎮 Partidas</button>
                <button class="tab-button" onclick="switchTab('bloques')">📚 Carga de Bloques</button>
                <button class="tab-button" onclick="switchTab('historico')">📊 Histórico</button>
            </div>
        </div>

        <!-- Pestaña Partidas -->
        <div id="partidas-tab" class="tab-content active">
            <!-- Sección Configuración de Partida -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Config.png" alt="Config" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Configuración de Partida</h2>
                <div class="section-content">
                    <div id="player-dashboard-root"></div>
                </div>
            </div>

            <!-- Sección Juegos Activos -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Juegos.png" alt="Juegos" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Juegos Activos</h2>
                <div class="section-content">
                    <div id="active-games-content"></div>
                </div>
            </div>
        </div>

        <!-- Pestaña Carga de Bloques -->
        <div id="bloques-tab" class="tab-content">
            <!-- Sección Bloques Cargados - Usando componente completo -->
            <div id="loaded-blocks-pjg-container"></div>

            <!-- Sección Bloques Disponibles -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Disponibles.png" alt="Disponibles" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Bloques Disponibles</h2>
                <div class="section-content">
                    <div id="available-blocks-pjg-container"></div>
                </div>
            </div>
        </div>

        <!-- Pestaña Histórico -->
        <div id="historico-tab" class="tab-content">
            <!-- Sección Historial de Partidas -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Historia.png" alt="Historia" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Historial de Partidas</h2>
                <div class="section-content">
                    <div id="games-history-content"></div>
                </div>
            </div>

            <!-- Sección Estadísticas -->
            <div class="section">
                <h2 class="section-title">📊 Estadísticas</h2>
                <div class="section-content">
                    <div id="statistics-content"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Script principal del panel -->
    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useContext, createContext } = React;

        // Context para el usuario actual
        const UserContext = createContext();
        const useUser = () => useContext(UserContext);

        // Context para idioma (completo)
        const LanguageContext = createContext();
        const useLanguage = () => useContext(LanguageContext);
        const LanguageProvider = ({ children }) => {
            const t = (key, params = {}) => {
                const translations = {
                    // Traducciones básicas
                    'loading': 'Cargando...',
                    'error': 'Error',
                    'game_setup_title': 'Configuración de partida',
                    'game_setup_category': 'Modalidad',
                    'game_setup_training': 'Entrenamiento',
                    'game_setup_competition': 'Competición',
                    'game_setup_mode': 'Juego',
                    'game_setup_blocks_topics': 'Selección de bloques',
                    'game_setup_configure': 'Configurar',
                    'game_setup_not_selected': 'No seleccionado',
                    'game_setup_all_topics': 'Todos los temas',
                    'game_setup_topics_selected': '{count} tema(s) seleccionado(s)',
                    'game_setup_button_create': 'Nueva Partida',
                    'game_setup_button_challenge': 'Enviar Reto',
                    'game_setup_challenge_user': 'Retar a un Usuario',
                    'game_setup_challenge_random': 'Retar a Aleatorio',
                    'game_setup_select_opponent': 'Selecciona un oponente',
                    'game_setup_selected': 'Seleccionado',
                    'challenge_sent': '¡Reto enviado correctamente!',
                    'challenge_no_users': 'No hay usuarios disponibles para retar.',
                    'add': 'Agregar',
                    'remove': 'Quitar',
                    'generic_cancel': 'Cancelar',
                    'topic_modal_title': 'Configurar Temas',
                    'topic_modal_subtitle': 'Seleccionar temas para "{blockName}"',
                    'topic_modal_deselect_all': 'Deseleccionar Todo',
                    'topic_modal_select_all': 'Seleccionar Todo',
                    'topic_modal_no_topics': 'Este bloque no tiene temas definidos en sus preguntas.',
                    'topic_modal_save': 'Guardar Selección',
                    'admin_blocks_by': 'por',
                    'active_games_title': 'Juegos Activos',
                    'block_management_title': 'Gestión de Bloques',
                    'game_history_title': 'Historial de Partidas',
                    'created_blocks_title': 'Mis Bloques Creados',
                    // Traducciones para modalidades de juego
                    'game_mode_classic': 'Modo Clásico',
                    'game_mode_timetrial': 'Modo Contrarreloj',
                    'game_mode_lives': 'Modo Vidas',
                    'game_mode_levels': 'Por Niveles',
                    'game_mode_streak': 'Racha de Aciertos',
                    'game_mode_exam': 'Examen Simulado',
                    'game_mode_duel': 'Duelo',
                    'game_mode_trivial': 'Trivial',
                    'game_mode_marathon': 'Maratón'
                };
                let text = translations[key] || key;
                Object.keys(params).forEach(param => {
                    text = text.replace(`{${param}}`, params[param]);
                });
                return text;
            };
            
            return React.createElement(LanguageContext.Provider, { value: { t } }, children);
        };

        // Componente TopicSelectionModal
        const TopicSelectionModal = ({ block, existingSelection, onSave, onClose }) => {
            const { t } = useLanguage();
            const [uniqueTopics, setUniqueTopics] = useState([]);
            const [isLoadingTopics, setIsLoadingTopics] = useState(true);
            const [selectedTopics, setSelectedTopics] = useState(new Set());

            // Cargar temas desde la API cuando se monta el componente
            useEffect(() => {
                const loadTopics = async () => {
                    if (!block || !window.apiDataService) return;
                    
                    setIsLoadingTopics(true);
                    try {
                        console.log(`🔍 Loading topics for block ${block.id} from topic_answers table`);
                        const topics = await window.apiDataService.fetchBlockTopics(block.id);
                        
                        // Extraer nombres únicos de temas y ordenarlos
                        const topicNames = [...new Set(topics.map(topic => topic.name || topic.topic || topic).filter(Boolean))].sort();
                        setUniqueTopics(topicNames);
                        console.log(`✅ Loaded ${topicNames.length} unique topics for block ${block.id}:`, topicNames);
                        
                        // Establecer selección inicial
                        if (existingSelection === 'all') {
                            setSelectedTopics(new Set(topicNames));
                        } else {
                            setSelectedTopics(new Set(existingSelection || []));
                        }
                    } catch (error) {
                        console.error(`❌ Error loading topics for block ${block.id}:`, error);
                        setUniqueTopics([]);
                    } finally {
                        setIsLoadingTopics(false);
                    }
                };
                
                loadTopics();
            }, [block, existingSelection]);

            const handleToggleTopic = (topic) => {
                setSelectedTopics(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(topic)) newSet.delete(topic);
                    else newSet.add(topic);
                    return newSet;
                });
            };

            const handleSelectAll = () => {
                if (selectedTopics.size === uniqueTopics.length) {
                    setSelectedTopics(new Set());
                } else {
                    setSelectedTopics(new Set(uniqueTopics));
                }
            };

            const handleSave = () => {
                if (selectedTopics.size === 0) {
                    onSave(block.id, null);
                } else if (selectedTopics.size === uniqueTopics.length) {
                    onSave(block.id, 'all');
                } else {
                    onSave(block.id, Array.from(selectedTopics));
                }
            };
            
            if (!block) return null;

            return React.createElement('div', {
                className: "fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50",
                onClick: onClose
            }, React.createElement('div', {
                className: "bg-slate-800 rounded-xl shadow-2xl w-full max-w-md m-4 border border-slate-600",
                onClick: e => e.stopPropagation()
            }, [
                React.createElement('div', {
                    key: 'header',
                    className: "p-6 border-b border-slate-600"
                }, [
                    React.createElement('h4', {
                        key: 'title',
                        className: "text-xl font-bold text-white"
                    }, t('topic_modal_title')),
                    React.createElement('p', {
                        key: 'subtitle',
                        className: "text-sm text-gray-400"
                    }, t('topic_modal_subtitle', {blockName: block.nombreCorto}))
                ]),
                React.createElement('div', {
                    key: 'content',
                    className: "p-6 max-h-96 overflow-y-auto"
                }, isLoadingTopics ? 
                    React.createElement('div', {
                        className: "text-center text-gray-400 py-8"
                    }, [
                        React.createElement('div', {
                            key: 'spinner',
                            className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"
                        }),
                        React.createElement('p', {
                            key: 'text'
                        }, 'Cargando temas...')
                    ]) :
                    uniqueTopics.length > 0 ? [
                        React.createElement('button', {
                            key: 'select-all',
                            onClick: handleSelectAll,
                            className: "w-full text-sm font-semibold bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-md transition-colors mb-4"
                        }, `${selectedTopics.size === uniqueTopics.length ? t('topic_modal_deselect_all') : t('topic_modal_select_all')} (${uniqueTopics.length})`),
                        React.createElement('div', {
                            key: 'topics',
                            className: "space-y-2"
                        }, uniqueTopics.map(topic =>
                            React.createElement('label', {
                                key: topic,
                                className: "flex items-center p-3 rounded-md hover:bg-slate-700 cursor-pointer transition-colors"
                            }, [
                                React.createElement('input', {
                                    key: 'checkbox',
                                    type: "checkbox",
                                    checked: selectedTopics.has(topic),
                                    onChange: () => handleToggleTopic(topic),
                                    className: "h-4 w-4 rounded border-slate-600 text-blue-600 bg-slate-800 focus:ring-blue-600 focus:ring-2"
                                }),
                                React.createElement('span', {
                                    key: 'label',
                                    className: "ml-3 text-white"
                                }, topic)
                            ])
                        ))
                    ] : React.createElement('p', {
                        className: "text-center text-gray-400 py-8"
                    }, t('topic_modal_no_topics'))),
                React.createElement('div', {
                    key: 'footer',
                    className: "p-4 bg-slate-900 flex justify-end gap-3 rounded-b-xl"
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: onClose,
                        className: "py-2 px-4 rounded-lg bg-slate-600 hover:bg-slate-500 text-white font-semibold transition-colors"
                    }, t('generic_cancel')),
                    React.createElement('button', {
                        key: 'save',
                        onClick: handleSave,
                        disabled: isLoadingTopics,
                        className: `py-2 px-4 rounded-lg font-bold transition-colors ${
                            isLoadingTopics 
                                ? 'bg-slate-600 text-gray-400 cursor-not-allowed' 
                                : 'bg-blue-600 hover:bg-blue-700 text-white'
                        }`
                    }, isLoadingTopics ? 'Cargando...' : t('topic_modal_save'))
                ])
            ]));
        };

        // Componente GameSetup completo
        const GameSetup = ({ blocks, onCreateGame, onSendChallenge }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [allUsers, setAllUsers] = useState([]);
            const [allProfiles, setAllProfiles] = useState({});
            
            const trainingModes = [
                { key: 'game_mode_classic', value: 'Modo Clásico', image: './Imagenes/Clasico.png'},
                { key: 'game_mode_timetrial', value: 'Modo Contrarreloj', image: './Imagenes/Contrarreloj.png'},
                { key: 'game_mode_lives', value: 'Modo Vidas', image: './Imagenes/Vidas.png'},
                { key: 'game_mode_levels', value: 'Por Niveles', image: './Imagenes/Niveles.png'},
                { key: 'game_mode_streak', value: 'Racha de Aciertos', image: './Imagenes/Racha.png'},
                { key: 'game_mode_exam', value: 'Examen Simulado', image: './Imagenes/Examen.png'},
            ];
            const competitionModes = [
                { key: 'game_mode_duel', value: 'Duelo', image: './Imagenes/Duelo.png' },
                { key: 'game_mode_trivial', value: 'Trivial', image: './Imagenes/Trivia.png' },
                { key: 'game_mode_marathon', value: 'Maratón', image: './Imagenes/Maraton.png' },
            ];

            const [category, setCategory] = useState('Entrenamiento');
            const [mode, setMode] = useState(trainingModes[0].value);
            const [configuredBlocks, setConfiguredBlocks] = useState({});
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [blockToConfigure, setBlockToConfigure] = useState(null);
            const [challengedUserId, setChallengedUserId] = useState('');
            const [challengeStatus, setChallengeStatus] = useState('');

            const isCompetitionMode = useMemo(() => category === 'Competición' && (mode === 'Duelo' || mode === 'Trivial'), [category, mode]);

            useEffect(() => {
                if (category === 'Entrenamiento') setMode(trainingModes[0].value);
                else setMode(competitionModes[0].value);
            }, [category]);
            
            useEffect(() => {
                const fetchUsersAndProfiles = async () => {
                    if (window.apiDataService) {
                        try {
                            const [users, profiles] = await Promise.all([
                                window.apiDataService.fetchAllUsers(),
                                window.apiDataService.fetchAllUserProfiles()
                            ]);
                            setAllUsers(users || []);
                            setAllProfiles(profiles || {});
                        } catch (error) {
                            console.error('Error fetching users:', error);
                        }
                    }
                };
                fetchUsersAndProfiles();
            }, []);
            
            const challengeableUsers = useMemo(() => {
                const selectedBlockIds = Object.keys(configuredBlocks).map(id => parseInt(id));
                if (!isCompetitionMode || selectedBlockIds.length === 0) return [];

                return allUsers.filter(user => {
                    if (user.isAdmin || user.id === currentUser.id) return false;
                    const profile = allProfiles[user.id];
                    if (!profile || !profile.loadedBlocks) return false;
                    
                    const userLoadedBlocks = profile.loadedBlocks.map(id => parseInt(id));
                    return selectedBlockIds.every(blockId => userLoadedBlocks.includes(blockId));
                });
            }, [allUsers, allProfiles, configuredBlocks, currentUser?.id, isCompetitionMode]);

            const handleToggleBlockForCompetition = (blockId) => {
                setConfiguredBlocks(prev => {
                    const newConfig = { ...prev };
                    if (newConfig[blockId]) {
                        delete newConfig[blockId];
                    } else {
                        newConfig[blockId] = { topics: 'all' };
                    }
                    return newConfig;
                });
            };

            const handleOpenModal = (block) => { setBlockToConfigure(block); setIsModalOpen(true); };
            const handleCloseModal = () => { setBlockToConfigure(null); setIsModalOpen(false); };
            
            const handleSaveTopicSelection = (blockId, topics) => {
                setConfiguredBlocks(prev => {
                    const newConfig = { ...prev };
                    if (topics) newConfig[blockId] = { topics };
                    else delete newConfig[blockId];
                    return newConfig;
                });
                handleCloseModal();
            };

            const handleGameAction = () => {
                if (Object.keys(configuredBlocks).length === 0) return;
                const gameConfig = { mode, config: configuredBlocks };
                
                // DEBUG: Log game configuration before sending
                console.log('🎮 GAME DEBUG - handleGameAction:', {
                    mode: mode,
                    configuredBlocks: configuredBlocks,
                    configuredBlocksKeys: Object.keys(configuredBlocks),
                    configuredBlocksLength: Object.keys(configuredBlocks).length,
                    gameConfig: gameConfig
                });
                
                if (isCompetitionMode) {
                    console.log('🎯 COMPETITION DEBUG - Challenge details:', {
                        isCompetitionMode: isCompetitionMode,
                        challengedUserId: challengedUserId,
                        challengeableUsersCount: challengeableUsers.length,
                        challengeableUsers: challengeableUsers
                    });
                    const challengedUser = challengeableUsers.find(u => u.id.toString() === challengedUserId.toString());
                    console.log('👤 Found challengedUser:', challengedUser);
                    if (!challengedUser) {
                        console.error('❌ No challenged user found!');
                        return;
                    }
                    console.log('📞 About to call onSendChallenge...');
                    onSendChallenge(challengedUser, gameConfig);
                    setChallengeStatus(t('challenge_sent'));
                    setTimeout(() => setChallengeStatus(''), 3000);
                } else {
                    onCreateGame(gameConfig);
                }

                setConfiguredBlocks({}); 
                setChallengedUserId('');
            };

            const handleRandomChallenge = () => {
                if (challengeableUsers.length === 0) return;
                const randomUser = challengeableUsers[Math.floor(Math.random() * challengeableUsers.length)];
                const gameConfig = { mode, config: configuredBlocks };
                onSendChallenge(randomUser, gameConfig);
                setChallengeStatus(t('challenge_sent'));
                setTimeout(() => setChallengeStatus(''), 3000);
                setConfiguredBlocks({});
                setChallengedUserId('');
            };
            
            const getBlockSelectionText = (blockId) => {
                const config = configuredBlocks[blockId];
                if (!config) return React.createElement('span', { className: "text-gray-400" }, t('game_setup_not_selected'));
                if (config.topics === 'all') return React.createElement('span', { className: "text-green-400" }, t('game_setup_all_topics'));
                return React.createElement('span', { className: "text-blue-400" }, t('game_setup_topics_selected', {count: config.topics.length}));
            };
            
            const buttonDisabled = Object.keys(configuredBlocks).length === 0 || (isCompetitionMode && !challengedUserId);
            const buttonText = isCompetitionMode ? t('game_setup_button_challenge') : t('game_setup_button_create');

            return React.createElement('div', { 
                className: "bg-slate-800 p-6 rounded-xl shadow-lg" 
            }, [
                isModalOpen && blockToConfigure && React.createElement(TopicSelectionModal, {
                    key: 'modal',
                    block: blockToConfigure,
                    existingSelection: configuredBlocks[blockToConfigure.id]?.topics,
                    onSave: handleSaveTopicSelection,
                    onClose: handleCloseModal
                }),
                
                // Content
                React.createElement('div', {
                    key: 'content',
                    className: "space-y-4"
                }, [
                    // Category selector
                    React.createElement('div', { key: 'category' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-1"
                        }, t('game_setup_category')),
                        React.createElement('select', {
                            key: 'select',
                            value: category,
                            onChange: (e) => setCategory(e.target.value),
                            className: "w-full bg-slate-900 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none"
                        }, [
                            React.createElement('option', { key: 'training', value: "Entrenamiento" }, t('game_setup_training')),
                            React.createElement('option', { key: 'competition', value: "Competición" }, t('game_setup_competition'))
                        ])
                    ]),

                    // Mode selector
                    React.createElement('div', { key: 'mode' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-2"
                        }, t('game_setup_mode')),
                        React.createElement('div', {
                            key: 'grid',
                            className: "grid grid-cols-2 sm:grid-cols-3 gap-3"
                        }, (category === 'Entrenamiento' ? trainingModes : competitionModes).map(m =>
                            React.createElement('button', {
                                key: m.key,
                                type: "button",
                                onClick: () => setMode(m.value),
                                className: `p-3 text-center rounded-lg border-2 transition-all duration-200 ${mode === m.value ? 'bg-blue-600/20 border-blue-600' : 'bg-slate-900 border-slate-600 hover:border-gray-400'}`
                            }, [
                                React.createElement('div', {
                                    key: 'image-container',
                                    className: "w-24 h-24 mx-auto mb-2 rounded-full bg-slate-700 flex items-center justify-center ring-1 ring-slate-600"
                                }, React.createElement('img', {
                                    key: 'image',
                                    src: m.image,
                                    alt: t(m.key),
                                    className: "h-16 w-16 object-contain"
                                })),
                                React.createElement('span', {
                                    key: 'text',
                                    className: "text-xs font-semibold text-white"
                                }, t(m.key))
                            ])
                        ))
                    ]),

                    // Competition mode options
                    isCompetitionMode && React.createElement('div', {
                        key: 'competition',
                        className: "p-3 bg-slate-900 rounded-lg space-y-2"
                    }, [
                        React.createElement('div', { key: 'opponent-select' }, [
                            React.createElement('label', {
                                key: 'label',
                                className: "block text-sm font-medium text-gray-400 mb-1"
                            }, t('game_setup_challenge_user')),
                            React.createElement('select', {
                                key: 'select',
                                value: challengedUserId,
                                onChange: (e) => setChallengedUserId(e.target.value),
                                className: "w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none",
                                disabled: Object.keys(configuredBlocks).length === 0
                            }, [
                                React.createElement('option', { key: 'default', value: "" }, t('game_setup_select_opponent')),
                                ...(challengeableUsers.length > 0 ? 
                                    challengeableUsers.map(user =>
                                        React.createElement('option', { key: user.id, value: user.id }, user.nickname)
                                    ) : 
                                    [React.createElement('option', { key: 'no-users', disabled: true }, t('challenge_no_users'))]
                                )
                            ])
                        ]),
                        React.createElement('div', {
                            key: 'divider',
                            className: "flex items-center gap-2"
                        }, [
                            React.createElement('div', { key: 'line1', className: "flex-grow border-t border-slate-600" }),
                            React.createElement('span', { key: 'or', className: "text-xs text-gray-400" }, 'O'),
                            React.createElement('div', { key: 'line2', className: "flex-grow border-t border-slate-600" })
                        ]),
                        React.createElement('button', {
                            key: 'random',
                            onClick: handleRandomChallenge,
                            disabled: challengeableUsers.length === 0,
                            className: "w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors disabled:bg-slate-700 disabled:cursor-not-allowed"
                        }, t('game_setup_challenge_random'))
                    ]),

                    // Block selection
                    React.createElement('div', { key: 'blocks' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-2"
                        }, t('game_setup_blocks_topics')),
                        React.createElement('div', {
                            key: 'list',
                            className: "max-h-40 overflow-y-auto space-y-2 p-1"
                        }, blocks.map(block =>
                            React.createElement('div', {
                                key: block.id,
                                className: "flex items-center justify-between p-2 rounded-md hover:bg-slate-700 transition-colors"
                            }, [
                                React.createElement('div', { key: 'info', className: "overflow-hidden" }, [
                                    React.createElement('p', {
                                        key: 'name',
                                        className: "font-semibold text-white truncate"
                                    }, block.nombreCorto),
                                    React.createElement('p', {
                                        key: 'creator',
                                        className: "text-xs text-gray-400 truncate"
                                    }, `${t('admin_blocks_by')} ${block.creatorNickname}`),
                                    React.createElement('p', {
                                        key: 'status',
                                        className: "text-xs mt-1"
                                    }, category === 'Competición' ? 
                                        (configuredBlocks[block.id] ? 
                                            React.createElement('span', { className: "text-green-400" }, t('game_setup_selected')) : 
                                            React.createElement('span', { className: "text-gray-400" }, t('game_setup_not_selected'))
                                        ) : getBlockSelectionText(block.id)
                                    )
                                ]),
                                category === 'Competición' ? 
                                    React.createElement('button', {
                                        key: 'toggle',
                                        onClick: () => handleToggleBlockForCompetition(block.id),
                                        className: `text-sm font-semibold py-1 px-3 rounded-md transition-colors ${configuredBlocks[block.id] ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'}`
                                    }, configuredBlocks[block.id] ? t('remove') : t('add')) :
                                    React.createElement('button', {
                                        key: 'config',
                                        onClick: () => handleOpenModal(block),
                                        className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-3 rounded-md transition-colors"
                                    }, t('game_setup_configure'))
                            ])
                        ))
                    ]),

                    // Challenge status
                    challengeStatus && React.createElement('p', {
                        key: 'status',
                        className: "text-center text-sm text-green-400 animate-pulse"
                    }, challengeStatus),

                    // Action button
                    React.createElement('button', {
                        key: 'action',
                        onClick: handleGameAction,
                        disabled: buttonDisabled,
                        className: "w-full mt-2 bg-blue-600 text-white font-bold py-2.5 px-4 rounded-lg hover:bg-blue-700 transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed"
                    }, buttonText)
                ])
            ]);
        };

        // Componente ActiveGames completo (con retos pendientes)
        const ActiveGames = ({ games, gameConfigurations, challenges, blocks, onDeleteGame, onNavigateToGame, onAcceptChallenge, onDeclineChallenge, handleDeleteConfiguration, onRepeatConfiguration, setCurrentView }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);

            const getGameConfigDetails = (config, metadata) => {
                if (!config || Object.keys(config).length === 0) return 'Sin configuración de bloques';
                
                if (metadata && metadata.blocks) {
                    const blockSummary = metadata.blocks.map(block => {
                        const topicInfo = block.isAllTopics 
                            ? 'todos los temas'
                            : `${block.selectedTopics.length} temas`;
                        return `${block.blockName} (${topicInfo}, ${block.questionCount} preguntas)`;
                    }).join(' | ');
                    
                    return `${metadata.summary.blockCount} bloques, ${metadata.summary.questionCount} preguntas: ${blockSummary}`;
                }
                
                return Object.entries(config).map(([blockId, blockConfig]) => {
                    const block = blocks.find(b => b.id === parseInt(blockId) || b.id === blockId);
                    const blockName = block ? block.nombreCorto : 'Bloque Desconocido';
                    const topicInfo = blockConfig.topics === 'all' 
                        ? 'todos los temas' 
                        : `${Array.isArray(blockConfig.topics) ? blockConfig.topics.length : 0} temas`;
                    return `${blockName} (${topicInfo})`;
                }).join(' | ');
            };

            const handleDeleteClick = (gameId) => {
                setConfirmingDeleteId(gameId);
            };
            
            const handleConfirmDelete = () => {
                if (confirmingDeleteId) {
                    onDeleteGame(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };

            const activeGames = games.filter(g => g.status === 'active');
            const completedGames = games.filter(g => g.status === 'completed');
            // Separate incoming challenges (where current user is challenged) from outgoing (where current user is challenger)
            const incomingChallenges = challenges.filter(c => 
                c.status === 'pending' && c.direction === 'incoming'
            );
            const outgoingChallenges = challenges.filter(c => 
                c.status === 'pending' && c.direction === 'outgoing'
            );
            
            // Show completed games as available to replay
            const gamesToShow = activeGames.length > 0 ? activeGames : completedGames;
            const sectionTitle = activeGames.length > 0 ? 'Partidas Activas' : 'Partidas Disponibles';
            const statusBadge = activeGames.length > 0 ? 'Activa' : 'Completada';
            const buttonText = activeGames.length > 0 ? '▶️ Continuar Partida' : '🔄 Jugar de Nuevo';


            // Enhanced helper for challenge configuration with more detail
            const getChallengeConfigDetails = (challenge) => {
                if (!challenge.config) return 'Sin configuración disponible';
                
                const config = challenge.config;
                const metadata = challenge.configurationMetadata;
                const mode = challenge.mode || 'Modo no especificado';
                
                let details = [];
                details.push(`🎮 Modo: ${mode}`);
                
                const blockIds = Object.keys(config);
                details.push(`📚 ${blockIds.length} bloque${blockIds.length !== 1 ? 's' : ''}`);
                
                if (metadata && metadata.blockDetails) {
                    const blockInfo = metadata.blockDetails.map(block => {
                        const blockConfig = config[block.id];
                        if (blockConfig && blockConfig.topics) {
                            return `• ${block.name} (${blockConfig.topics.length} tema${blockConfig.topics.length !== 1 ? 's' : ''})`;
                        }
                        return `• ${block.name}`;
                    });
                    details.push(...blockInfo);
                }
                
                return details;
            };

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col h-full"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminación'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¿Estás seguro de que quieres eliminar este juego?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                gamesToShow.length > 0 && React.createElement('div', {
                    key: 'header',
                    className: "flex justify-end mb-4 flex-shrink-0"
                }, React.createElement('a', {
                    key: 'view-all',
                    href: "/all-games.html",
                    className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-3 rounded-md transition-colors"
                }, `Ver todos (${gamesToShow.length})`)),
                
                React.createElement('div', {
                    key: 'content',
                    className: "space-y-4 overflow-y-auto pr-2 flex-grow"
                }, [
                    // Incoming challenges (user is being challenged)
                    incomingChallenges.length > 0 && React.createElement('div', { key: 'incoming-challenges' }, [
                        React.createElement('h4', {
                            key: 'incoming-title',
                            className: "font-semibold text-amber-400 mb-2"
                        }, 'Retos Recibidos'),
                        React.createElement('ul', {
                            key: 'incoming-list',
                            className: "space-y-3 mb-4"
                        }, incomingChallenges.map(challenge => {
                            const challenger = challenge.challenger;
                            const configDetails = getChallengeConfigDetails(challenge);
                            
                            return React.createElement('li', {
                                key: challenge.id,
                                className: "p-4 rounded-md bg-amber-500/10 border border-amber-500/30"
                            }, [
                                React.createElement('div', { key: 'challenge-header', className: "flex items-start gap-3 mb-3" }, [
                                    React.createElement('div', {
                                        key: 'sword-icon',
                                        className: "h-8 w-8 text-amber-400 flex-shrink-0 flex items-center justify-center"
                                    }, '⚔️'),
                                    React.createElement('div', { key: 'challenge-main', className: "flex-grow" }, [
                                        React.createElement('p', {
                                            key: 'challenger',
                                            className: "font-bold text-white text-lg"
                                        }, `Reto de ${challenger?.nickname}`),
                                        React.createElement('p', {
                                            key: 'mode',
                                            className: "text-amber-300 font-semibold"
                                        }, challenge.mode || 'Modo no especificado')
                                    ])
                                ]),
                                
                                React.createElement('div', { key: 'challenge-config', className: "mb-4 pl-11" }, [
                                    React.createElement('div', {
                                        key: 'config-title',
                                        className: "text-sm font-semibold text-gray-300 mb-2"
                                    }, '📋 Configuración de la partida:'),
                                    React.createElement('div', {
                                        key: 'config-details',
                                        className: "text-sm text-gray-400 space-y-1"
                                    }, configDetails.map((detail, index) => 
                                        React.createElement('div', { key: index }, detail)
                                    ))
                                ]),
                                
                                React.createElement('div', { key: 'challenge-actions', className: "flex justify-end gap-3" }, [
                                    React.createElement('button', {
                                        key: 'decline',
                                        onClick: () => handleDeclineWithReason(challenge.id, challenger?.nickname),
                                        className: "py-2 px-4 text-sm rounded-lg bg-red-600 hover:bg-red-700 text-white font-bold transition-colors"
                                    }, '❌ Declinar'),
                                    React.createElement('button', {
                                        key: 'accept',
                                        onClick: () => handleAcceptAndStartGame(challenge.id, challenge),
                                        className: "py-2 px-4 text-sm rounded-lg bg-green-600 hover:bg-green-700 text-white font-bold transition-colors"
                                    }, '✅ Aceptar y Jugar')
                                ])
                            ]);
                        }))
                    ]),

                    // Outgoing challenges (user has challenged others)
                    outgoingChallenges.length > 0 && React.createElement('div', { key: 'outgoing-challenges' }, [
                        React.createElement('h4', {
                            key: 'outgoing-title',
                            className: "font-semibold text-blue-400 mb-2"
                        }, 'Retos Enviados'),
                        React.createElement('ul', {
                            key: 'outgoing-list',
                            className: "space-y-3 mb-4"
                        }, outgoingChallenges.map(challenge => {
                            const challenged = challenge.challenged;
                            return React.createElement('li', {
                                key: challenge.id,
                                className: "p-3 rounded-md bg-blue-500/10 border border-blue-500/30"
                            }, [
                                React.createElement('div', { key: 'challenge-info', className: "flex items-center gap-3" }, [
                                    React.createElement('div', {
                                        key: 'clock-icon',
                                        className: "h-6 w-6 text-blue-400 flex-shrink-0"
                                    }, '⏳'),
                                    React.createElement('div', { key: 'challenge-details', className: "flex-grow overflow-hidden" }, [
                                        React.createElement('p', {
                                            key: 'challenged',
                                            className: "font-semibold text-white truncate"
                                        }, `Retaste a ${challenged?.nickname} en ${challenge.mode}`),
                                        React.createElement('p', {
                                            key: 'status',
                                            className: "text-xs text-blue-400"
                                        }, 'Esperando respuesta...'),
                                        React.createElement('p', {
                                            key: 'config',
                                            className: "text-xs text-gray-400 truncate",
                                            title: getGameConfigDetails(challenge.config, challenge.configurationMetadata)
                                        }, getGameConfigDetails(challenge.config, challenge.configurationMetadata))
                                    ])
                                ])
                            ]);
                        }))
                    ]),

                    gamesToShow.length > 0 && React.createElement('div', { key: 'active-games-section' }, [
                        React.createElement('h4', {
                            key: 'active-games-title',
                            className: "font-semibold text-blue-400 mb-2"
                        }, sectionTitle),
                        React.createElement('ul', {
                            key: 'active-games-list',
                            className: "space-y-3 mb-4"
                        }, gamesToShow.map(game => React.createElement('li', {
                            key: game.id,
                            className: "p-3 rounded-md bg-blue-900/20 border border-blue-500/30"
                        }, [
                            React.createElement('div', { key: 'game-header', className: "flex items-center justify-between mb-2" }, [
                                React.createElement('div', { key: 'game-info', className: "flex items-center gap-2" }, [
                                    React.createElement('div', {
                                        key: 'game-icon',
                                        className: "h-6 w-6 text-blue-400 flex-shrink-0"
                                    }, '🎮'),
                                    React.createElement('span', {
                                        key: 'game-mode',
                                        className: "font-semibold text-white"
                                    }, game.mode || 'Modo Clásico'),
                                    React.createElement('span', {
                                        key: 'game-status',
                                        className: `text-xs px-2 py-0.5 rounded text-white ${activeGames.length > 0 ? 'bg-green-600' : 'bg-gray-600'}`
                                    }, statusBadge)
                                ]),
                                React.createElement('button', {
                                    key: 'delete-game',
                                    onClick: () => handleDeleteClick(game.id),
                                    className: "text-red-400 hover:text-red-300 text-sm",
                                    title: "Eliminar juego"
                                }, '🗑️')
                            ]),
                            React.createElement('div', { key: 'game-config', className: "mb-3" }, [
                                React.createElement('p', {
                                    key: 'config-details',
                                    className: "text-xs text-gray-300"
                                }, getGameConfigDetails(game.config, game.configurationMetadata))
                            ]),
                            React.createElement('button', {
                                key: 'continue-game',
                                onClick: () => onNavigateToGame(game),
                                className: "w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm"
                            }, buttonText)
                        ])))
                    ]),

                    gamesToShow.length === 0 && React.createElement('div', {
                        key: 'no-games',
                        className: "text-center py-6 flex-grow flex items-center justify-center"
                    }, React.createElement('div', { key: 'no-games-content' }, [
                        React.createElement('p', { key: 'no-games-text', className: "text-gray-400" }, 'No hay juegos disponibles'),
                        React.createElement('p', { key: 'no-games-hint', className: "text-sm text-gray-500 mt-1" }, 'Crea una nueva partida para empezar')
                    ]))
                ])
            ]);
        };

        // Componente UserBlockManagement completo (con progreso y estadísticas)
        const UserBlockManagement = ({ blocks, onViewBlock, onDeleteBlock, onOpenAddBlockModal, onOpenStatsModal, setCurrentView }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);
            const [expandedBlockId, setExpandedBlockId] = useState(null);

            const handleDeleteClick = (blockId) => {
                setConfirmingDeleteId(blockId);
            };

            const handleConfirmDelete = () => {
                if (confirmingDeleteId) {
                    onDeleteBlock(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };
            
            const getProgressBarColor = (percentage) => {
                if (percentage < 40) return 'bg-red-600';
                if (percentage < 70) return 'bg-amber-500';
                return 'bg-green-600';
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminación'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¿Estás seguro de que quieres eliminar este bloque?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                hasRole(currentUser, 'creador') && React.createElement('div', {
                    key: 'actions',
                    className: "flex justify-end mb-4"
                }, React.createElement('button', {
                    key: 'create',
                    onClick: () => window.location.href = './add-question.html',
                    className: "text-xs font-semibold bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 rounded-md transition-colors"
                }, 'Crear Nuevo Bloque')),

                blocks.length > 0 ? React.createElement('div', {
                    key: 'blocks-list',
                    className: "space-y-3 overflow-y-auto max-h-96 pr-2 flex-grow"
                }, blocks.map(block =>
                    React.createElement('div', {
                        key: block.id,
                        className: "p-3 rounded-md bg-slate-900 hover:bg-slate-700 transition-colors group"
                    }, [
                        React.createElement('div', { key: 'block-header', className: "flex items-start justify-between" }, [
                            React.createElement('div', {
                                key: 'block-info',
                                onClick: () => onViewBlock(block.id),
                                className: "flex items-center gap-3 overflow-hidden flex-grow cursor-pointer"
                            }, [
                                React.createElement('img', {
                                    key: 'image',
                                    className: "h-10 w-16 rounded object-cover flex-shrink-0",
                                    src: block.urlImagenBloque,
                                    alt: block.nombreCorto
                                }),
                                React.createElement('div', { key: 'details', className: "overflow-hidden" }, [
                                    React.createElement('p', {
                                        key: 'name',
                                        className: "font-semibold text-white truncate"
                                    }, block.nombreCorto),
                                    React.createElement('p', {
                                        key: 'meta',
                                        className: "text-xs text-gray-400 truncate"
                                    }, `por ${block.creatorNickname} • ${block.totalPreguntas} preguntas`)
                                ])
                            ]),
                            React.createElement('div', { key: 'block-actions', className: "flex items-center gap-1 flex-shrink-0" }, [
                                React.createElement('button', {
                                    key: 'expand',
                                    onClick: () => setExpandedBlockId(prev => prev === block.id ? null : block.id),
                                    className: "text-xs font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-2 rounded-md transition-colors"
                                }, expandedBlockId === block.id ? 'Ocultar' : 'Ver Detalles'),
                                hasRole(currentUser, 'creador') && React.createElement('button', {
                                    key: 'edit',
                                    onClick: (e) => {
                                        e.stopPropagation();
                                        window.location.href = `block-questions.html?blockId=${block.id}&returnUrl=jugadores-panel-gaming.html&viewMode=edit`;
                                    },
                                    className: "p-2 rounded-full text-blue-400 hover:bg-blue-400/20 opacity-0 group-hover:opacity-100 transition-opacity"
                                }, '✏️'),
                                React.createElement('button', {
                                    key: 'delete',
                                    onClick: (e) => {
                                        e.stopPropagation();
                                        handleDeleteClick(block.id);
                                    },
                                    className: "p-2 rounded-full text-red-400 hover:bg-red-400/20 opacity-0 group-hover:opacity-100 transition-opacity"
                                }, '🗑️')
                            ])
                        ]),
                        React.createElement('div', { key: 'progress', className: "mt-3" }, [
                            React.createElement('div', { key: 'progress-header', className: "flex justify-between items-center mb-1" }, [
                                React.createElement('span', {
                                    key: 'progress-label',
                                    className: "text-xs font-medium text-gray-400"
                                }, 'Progreso de Estudio'),
                                React.createElement('div', { key: 'progress-actions', className: "flex items-center gap-2" }, [
                                    React.createElement('span', {
                                        key: 'progress-value',
                                        className: "text-xs font-medium text-white"
                                    }, `${block.studyProgress ?? 0}%`),
                                    React.createElement('button', {
                                        key: 'stats',
                                        onClick: () => onOpenStatsModal && onOpenStatsModal(block),
                                        title: `Estadísticas de ${block.nombreCorto}`,
                                        className: "text-xs font-bold bg-slate-600 hover:bg-gray-400 text-white py-1 px-3 rounded-md transition-colors"
                                    }, 'STAT')
                                ])
                            ]),
                            React.createElement('div', {
                                key: 'progress-bar-bg',
                                className: "w-full bg-slate-700 rounded-full h-1.5"
                            }, React.createElement('div', {
                                key: 'progress-bar-fill',
                                className: `${getProgressBarColor(block.studyProgress)} h-1.5 rounded-full transition-all duration-500`,
                                style: { width: `${block.studyProgress ?? 0}%` }
                            }))
                        ]),

                        expandedBlockId === block.id && React.createElement('div', {
                            key: 'expanded',
                            className: "mt-4 pt-4 border-t border-slate-600 space-y-2"
                        }, block.topicsWithStats && block.topicsWithStats.length > 0 ? 
                            block.topicsWithStats.map(topic =>
                                React.createElement('div', { key: topic.name }, [
                                    React.createElement('div', { key: 'topic-header', className: "flex justify-between mb-1" }, [
                                        React.createElement('span', {
                                            key: 'topic-name',
                                            className: "text-xs font-medium text-gray-400 truncate pr-2"
                                        }, topic.name),
                                        React.createElement('span', {
                                            key: 'topic-score',
                                            className: "text-xs font-medium text-white"
                                        }, `${topic.score}%`)
                                    ]),
                                    React.createElement('div', {
                                        key: 'topic-progress-bg',
                                        className: "w-full bg-slate-700 rounded-full h-1.5"
                                    }, React.createElement('div', {
                                        key: 'topic-progress-fill',
                                        className: `${getProgressBarColor(topic.score)} h-1.5 rounded-full transition-all duration-500`,
                                        style: { width: `${topic.score}%` }
                                    }))
                                ])
                            ) : 
                            React.createElement('p', {
                                key: 'no-topics',
                                className: "text-xs text-gray-400 text-center"
                            }, 'Este bloque no tiene temas con estadísticas')
                        )
                    ])
                )) : React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-6 flex-grow flex items-center justify-center"
                }, React.createElement('div', { key: 'no-blocks-content' }, [
                    React.createElement('p', { key: 'no-blocks-text', className: "text-gray-400 mb-3" }, 'No hay bloques cargados'),
                    React.createElement('p', { key: 'no-blocks-hint', className: "text-gray-500 text-sm" }, [
                        hasRole(currentUser, 'creador') ? [
                            'Puedes ',
                            React.createElement('button', {
                                key: 'create-link',
                                onClick: () => window.location.href = './add-question.html',
                                className: "text-blue-400 hover:underline"
                            }, 'crear un nuevo bloque'),
                            ' o '
                        ] : null,
                        'cargar bloques desde ',
                        React.createElement('a', {
                            key: 'available-link',
                            href: "available-blocks.html",
                            className: "text-blue-400 hover:underline"
                        }, 'Bloques Disponibles')
                    ])
                ]))
            ]);
        };

        // Componente CreatedBlocksManagement para usuarios creadores
        const CreatedBlocksManagement = ({ blocks, setCurrentView, onDeleteBlock }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);

            const handleDeleteClick = (blockId) => {
                setConfirmingDeleteId(blockId);
            };

            const handleConfirmDelete = () => {
                if (confirmingDeleteId && onDeleteBlock) {
                    onDeleteBlock(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            // Solo mostrar si el usuario es creador
            if (!hasRole(currentUser, 'creador')) {
                return null;
            }

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminación'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¿Estás seguro de que quieres eliminar este bloque creado?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                React.createElement('div', {
                    key: 'header',
                    className: "flex items-center justify-between mb-4 flex-shrink-0"
                }, [
                    React.createElement('div', { key: 'title-section', className: "flex items-center" }, [
                        React.createElement('img', {
                            key: 'icon',
                            src: "./Imagenes/Creados.png",
                            alt: "Created Blocks",
                            className: "h-10 w-10 mr-3"
                        }),
                        React.createElement('h3', {
                            key: 'title',
                            className: "text-xl font-bold text-white"
                        }, 'Mis Bloques Creados')
                    ]),
                    React.createElement('a', {
                        key: 'manage-all',
                        href: "all-blocks.html",
                        className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1.5 px-3 rounded-md transition-colors"
                    }, `Gestionar (${blocks.length})`)
                ]),

                blocks.length > 0 ? React.createElement('div', {
                    key: 'blocks-list',
                    className: "space-y-3 overflow-y-auto max-h-96 pr-2 flex-grow"
                }, blocks.slice(0, 5).map(block =>
                    React.createElement('div', {
                        key: block.id,
                        className: "flex items-center justify-between p-3 rounded-md bg-slate-900 group"
                    }, [
                        React.createElement('div', {
                            key: 'block-content',
                            className: "flex items-center gap-3 overflow-hidden flex-grow"
                        }, [
                            React.createElement('img', {
                                key: 'image',
                                className: "h-10 w-16 rounded object-cover flex-shrink-0",
                                src: block.urlImagenBloque,
                                alt: block.nombreCorto
                            }),
                            React.createElement('div', { key: 'details', className: "overflow-hidden" }, [
                                React.createElement('p', {
                                    key: 'name',
                                    className: "font-semibold text-white truncate"
                                }, block.nombreCorto),
                                React.createElement('p', {
                                    key: 'questions',
                                    className: "text-xs text-gray-400"
                                }, `${block.totalPreguntas || block.questionCount || 0} preguntas`)
                            ])
                        ]),
                        React.createElement('div', {
                            key: 'actions',
                            className: "flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"
                        }, [
                            React.createElement('button', {
                                key: 'edit',
                                onClick: () => window.location.href = `block-questions.html?blockId=${block.id}&returnUrl=jugadores-panel-gaming.html&viewMode=edit`,
                                className: "text-xs font-semibold bg-blue-600 hover:bg-blue-700 text-white py-1.5 px-3 rounded-md transition-colors"
                            }, 'Editar'),
                            React.createElement('button', {
                                key: 'delete',
                                onClick: () => handleDeleteClick(block.id),
                                className: "text-xs font-semibold bg-red-600/20 hover:bg-red-600/40 text-red-400 py-1.5 px-3 rounded-md transition-colors"
                            }, 'Eliminar')
                        ])
                    ])
                )) : React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-6 flex-grow flex items-center justify-center"
                }, React.createElement('div', { key: 'no-blocks-content' }, [
                    React.createElement('p', { key: 'no-blocks-text', className: "text-gray-400 mb-3" }, 'No has creado ningún bloque'),
                    React.createElement('p', { key: 'no-blocks-hint', className: "text-sm text-gray-500" }, [
                        'Comienza ',
                        React.createElement('a', {
                            key: 'create-link',
                            href: './add-question.html',
                            className: "text-blue-400 hover:underline"
                        }, 'creando tu primer bloque'),
                        ' de preguntas'
                    ])
                ]))
            ]);
        };

        // Componente principal del dashboard de jugadores
        const PlayerDashboard = () => {
            const { t } = useLanguage();
            const [currentUser, setCurrentUser] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [blocks, setBlocks] = useState([]);
            const [createdBlocks, setCreatedBlocks] = useState([]);
            const [availableBlocks, setAvailableBlocks] = useState([]);
            const [loadedBlockIds, setLoadedBlockIds] = useState([]);
            const [games, setGames] = useState([]);
            const [gameConfigurations, setGameConfigurations] = useState([]);
            const [challenges, setChallenges] = useState([]);
            const [gameHistory, setGameHistory] = useState([]);
            const [allUsers, setAllUsers] = useState([]);
            const [error, setError] = useState(null);
            const [message, setMessage] = useState('');

            // Cargar datos del usuario desde localStorage
            useEffect(() => {
                const loadUserSession = () => {
                    try {
                        const sessionString = localStorage.getItem('playtest_session');
                        const token = localStorage.getItem('playtest_auth_token');
                        
                        if (sessionString && token) {
                            const session = JSON.parse(sessionString);
                            if (session && session.userId && session.nickname) {
                                setCurrentUser({
                                    id: session.userId,
                                    nickname: session.nickname
                                });
                                
                                // Configurar token en apiDataService si existe
                                if (window.apiDataService && !window.apiDataService.token) {
                                    window.apiDataService.token = token;
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error loading user session:', e);
                    } finally {
                        setIsLoading(false);
                    }
                };

                loadUserSession();
            }, []);

            // Cargar datos del jugador
            const loadPlayerData = useCallback(async () => {
                if (!currentUser) return;
                
                try {
                    setError(null);
                    setIsLoading(true);
                    
                    if (window.apiDataService) {
                        const [
                            fetchedGames,
                            fetchedGameConfigurations,
                            fetchedAllUsers,
                            fetchedChallenges,
                            fetchedHistory,
                            loadedBlocks,
                            fetchedCreatedBlocks,
                            fetchedAvailableBlocks,
                            userProfile
                        ] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchGameConfigurations(),
                            window.apiDataService.fetchAllUsers(),
                            window.apiDataService.fetchChallengesForUser(currentUser.id),
                            window.apiDataService.fetchGameHistory(currentUser.id),
                            window.apiDataService.fetchLoadedBlocks(),
                            window.apiDataService.fetchCreatedBlocks(),
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);

                        setGames(fetchedGames || []);
                        setGameConfigurations(fetchedGameConfigurations || []);
                        setAllUsers(fetchedAllUsers || []);
                        setChallenges(fetchedChallenges || []);
                        setGameHistory(fetchedHistory || []);
                        setBlocks(loadedBlocks || []);
                        setCreatedBlocks(fetchedCreatedBlocks || []);
                        setAvailableBlocks(fetchedAvailableBlocks || []);
                        setLoadedBlockIds((userProfile?.loadedBlocks || []).map(id => parseInt(id)));
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al cargar datos: ${err.message}` : 'Error desconocido.');
                } finally {
                    setIsLoading(false);
                }
            }, [currentUser]);

            useEffect(() => {
                loadPlayerData();
                // Make refresh function available globally for game configuration dashboard
                window.refreshPlayerDashboardData = loadPlayerData;
            }, [loadPlayerData]);

            // Navegación a juegos
            const onNavigateToGame = (game) => {
                const isInProgress = (game.mode === 'Duelo' || game.mode === 'Trivial') && 
                    (game.gameState || game.turnState || (game.round && game.round > 0));

                if (isInProgress) {
                    const targetPage = game.mode === 'Duelo' ? 'game-duel.html' : 'game-trivial.html';
                    window.location.href = `${targetPage}?gameId=${game.id}`;
                } else {
                    window.location.href = `active-game.html?gameId=${game.id}`;
                }
            };

            // Crear nuevo juego
            const handleCreateGame = async (gameConfig) => {
                // DEBUG: Log received gameConfig
                console.log('📨 GAME DEBUG - handleCreateGame received:', {
                    gameConfig: gameConfig,
                    gameConfigType: typeof gameConfig,
                    gameConfigKeys: gameConfig ? Object.keys(gameConfig) : 'null',
                    hasMode: gameConfig?.mode,
                    hasConfig: gameConfig?.config,
                    configKeys: gameConfig?.config ? Object.keys(gameConfig.config) : 'no config'
                });
                
                try {
                    if (window.apiDataService) {
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            await loadPlayerData();
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al crear juego: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteGame = async (gameId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameForUser(currentUser.id, gameId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar juego: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleAcceptChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al aceptar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeclineChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.declineChallenge(currentUser.id, challengeId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al declinar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            // New enhanced function to accept challenge and start game directly
            const handleAcceptAndStartGame = async (challengeId, challenge) => {
                try {
                    if (window.apiDataService) {
                        console.log('🎮 Accepting challenge and starting game:', { challengeId, challenge });
                        
                        // Accept the challenge (this changes status from 'pending' to 'active')
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        
                        // Navigate directly to the game with the challenge's game ID
                        console.log('🚀 Redirecting to game:', challengeId);
                        setCurrentView('game');
                        setCurrentGameId(challengeId);
                        
                        // Refresh data to remove the challenge from pending list
                        await loadPlayerData();
                        
                        setMessage(`¡Reto aceptado! Iniciando partida...`);
                        setTimeout(() => setMessage(''), 2000);
                    }
                } catch (err) {
                    console.error('❌ Error accepting challenge and starting game:', err);
                    setError(err instanceof Error ? `Error al aceptar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            // New function to decline with reason and notify challenger
            const handleDeclineWithReason = async (challengeId, challengerNickname) => {
                const reason = prompt(
                    `¿Por qué declinas el reto de ${challengerNickname}?\n\n(Opcional: Puedes dejar este campo vacío o escribir una razón que será enviada al retador)`
                );
                
                // Allow cancellation
                if (reason === null) return;
                
                try {
                    if (window.apiDataService) {
                        console.log('❌ Declining challenge with reason:', { challengeId, reason });
                        
                        // Send decline with reason to backend
                        await window.apiDataService.declineChallengeWithReason(currentUser.id, challengeId, reason || '');
                        
                        // Refresh data
                        await loadPlayerData();
                        
                        const message = reason 
                            ? `Reto declinado. Se ha enviado tu respuesta a ${challengerNickname}.`
                            : `Reto declinado.`;
                        setMessage(message);
                        setTimeout(() => setMessage(''), 3000);
                    }
                } catch (err) {
                    console.error('❌ Error declining challenge with reason:', err);
                    setError(err instanceof Error ? `Error al declinar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteConfiguration = async (configId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameConfiguration(configId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar configuración: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleRepeatConfiguration = async (config) => {
                try {
                    if (window.apiDataService) {
                        const gameConfig = { 
                            mode: config.game_type || config.gameType || 'Partida', 
                            config: config.configuration || config.config 
                        };
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            await loadPlayerData();
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al repetir configuración: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteBlock = async (blockId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteLoadedBlock(blockId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar bloque: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleViewBlock = (blockId) => {
                window.location.href = `block-questions.html?blockId=${blockId}&returnUrl=jugadores-panel-gaming.html&viewMode=readonly`;
            };

            const handleOpenStatsModal = (block) => {
                // Implementar modal de estadísticas o redirigir a página de estadísticas
                console.log('Abrir estadísticas para bloque:', block.nombreCorto);
            };

            const viewBlockQuestions = (blockId) => {
                window.location.href = `block-questions.html?blockId=${blockId}&returnUrl=jugadores-panel-gaming.html&viewMode=readonly`;
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "flex justify-center items-center h-64" 
                }, React.createElement('div', { 
                    className: "text-center text-white" 
                }, t('loading')));
            }

            if (error) {
                return React.createElement('div', { 
                    className: "text-center text-red-400 bg-red-500/10 p-4 rounded-lg m-4" 
                }, `${t('error')}: ${error}`);
            }

            if (!currentUser) {
                return React.createElement('div', { 
                    className: "text-center text-white p-4" 
                }, 'Usuario no encontrado. Regresa a la página de inicio.');
            }

            // Enviar reto
            const handleSendChallenge = async (challengedUser, gameConfig) => {
                console.log('📨 CHALLENGE DEBUG - handleSendChallenge received:', {
                    challengedUser: challengedUser,
                    gameConfig: gameConfig
                });
                
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.createChallenge(
                            currentUser,
                            challengedUser,
                            gameConfig
                        );
                        
                        // Refresh data to show new challenge
                        await loadPlayerData();
                        console.log('✅ Challenge sent successfully to:', challengedUser.nickname);
                        
                        // Show success message
                        setMessage(`¡Reto enviado exitosamente a ${challengedUser.nickname}!`);
                        setTimeout(() => setMessage(''), 3000);
                    }
                } catch (error) {
                    console.error('❌ Error sending challenge:', error);
                    setError('Error al enviar el reto. Inténtalo de nuevo.');
                }
            };

            return React.createElement('div', { 
                className: "container mx-auto px-4 py-6 space-y-8 animate-fade-in" 
            }, [
                // Message display
                message && React.createElement('div', {
                    key: 'message',
                    className: `mb-4 p-3 rounded-lg text-center ${message.includes('Error') ? 'bg-red-500/20 text-red-300' : 'bg-green-500/20 text-green-300'}`
                }, message),
                
                // Bienvenida
                // Componente principal
                React.createElement(GameSetup, {
                    key: 'game-setup',
                    blocks: blocks,
                    onCreateGame: handleCreateGame,
                    onSendChallenge: handleSendChallenge
                })
            ]);
        };

        // Aplicación principal
        const App = () => {
            const [currentUser] = useState({ nickname: 'Jugador' }); // Simplificado para esta versión
            
            return React.createElement(LanguageProvider, {}, 
                React.createElement(UserContext.Provider, { value: { currentUser } },
                    React.createElement(PlayerDashboard, {})
                )
            );
        };

        // Renderizar la aplicación principal solo en la pestaña de Partidas
        const root = ReactDOM.createRoot(document.getElementById('player-dashboard-root'));
        root.render(React.createElement(App));

        // Crear componentes completos y funcionales para las pestañas
        const TabBlocksComponent = () => {
            const [tabBlocks, setTabBlocks] = useState([]);
            const [tabCreatedBlocks, setTabCreatedBlocks] = useState([]);
            const [currentUser, setCurrentUser] = useState(null);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const loadBlocksData = async () => {
                    try {
                        setIsLoading(true);
                        const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                        
                        if (!window.apiDataService) {
                            setTimeout(loadBlocksData, 1000);
                            return;
                        }
                        
                        const userId = session.id || session.userId;
                        if (!userId) {
                            return;
                        }

                        setCurrentUser(session);
                        
                        const [blocks, createdBlocks] = await Promise.all([
                            window.apiDataService.fetchLoadedBlocks(),
                            window.apiDataService.fetchCreatedBlocks(userId)
                        ]);
                        
                        setTabBlocks(blocks || []);
                        setTabCreatedBlocks(createdBlocks || []);
                    } catch (error) {
                        console.error('Error loading blocks data:', error);
                    } finally {
                        setIsLoading(false);
                    }
                };
                loadBlocksData();
            }, []);

            const handleViewBlock = (blockId) => {
                window.location.href = `game-classic.html?blockId=${blockId}`;
            };

            const handleDeleteBlock = async (blockId) => {
                if (window.apiDataService && currentUser) {
                    try {
                        const userId = currentUser.id || currentUser.userId;
                        await window.apiDataService.deleteBlockForUser(userId, blockId);
                        setTabBlocks(prev => prev.filter(b => b.id !== blockId));
                        setTabCreatedBlocks(prev => prev.filter(b => b.id !== blockId));
                    } catch (error) {
                        console.error('Error deleting block:', error);
                    }
                }
            };

            const handleOpenStatsModal = () => {
                // Implementar modal de estadísticas si es necesario
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando bloques...')
                ]);
            }

            return React.createElement('div', { className: "space-y-6" }, [
                // UserBlockManagement completo
                React.createElement(UserBlockManagement, {
                    key: 'tab-user-block-management',
                    blocks: tabBlocks,
                    onViewBlock: handleViewBlock,
                    onDeleteBlock: handleDeleteBlock,
                    onOpenAddBlockModal: () => {},
                    onOpenStatsModal: handleOpenStatsModal,
                    setCurrentView: () => {}
                }),

                // CreatedBlocksManagement para usuarios creadores
                hasRole(currentUser, 'creador') && React.createElement(CreatedBlocksManagement, {
                    key: 'tab-created-blocks-management',
                    blocks: tabCreatedBlocks,
                    setCurrentView: () => {},
                    onDeleteBlock: handleDeleteBlock
                })
            ]);
        };

        // Componente AvailableBlocks completo (funcionalidades de available-blocks.html)
        const AvailableBlocksComponent = () => {
            const [availableBlocks, setAvailableBlocks] = useState([]);
            const [filteredBlocks, setFilteredBlocks] = useState([]);
            const [loadedBlockIds, setLoadedBlockIds] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [searchTerm, setSearchTerm] = useState('');
            const [loadingActions, setLoadingActions] = useState({});
            const [message, setMessage] = useState('');
            
            // Filtros de metadata
            const [blockMetadata, setBlockMetadata] = useState({ types: [], levels: [], states: [] });
            const [selectedTipo, setSelectedTipo] = useState('');
            const [selectedNivel, setSelectedNivel] = useState('');
            const [selectedEstado, setSelectedEstado] = useState('');

            useEffect(() => {
                loadData();
                loadMetadata();
            }, []);

            // Aplicar filtros cuando cambien los valores
            useEffect(() => {
                applyFilters();
            }, [availableBlocks, searchTerm, selectedTipo, selectedNivel, selectedEstado]);

            const loadData = async () => {
                try {
                    setIsLoading(true);
                    const currentUser = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                    
                    if (!window.apiDataService) {
                        setTimeout(loadData, 1000);
                        return;
                    }
                    
                    const userId = currentUser.id || currentUser.userId;
                    if (!userId) {
                        return;
                    }

                    const [available, profile] = await Promise.all([
                        window.apiDataService.fetchAvailableBlocks(),
                        window.apiDataService.getUserProfile()
                    ]);
                    
                    setAvailableBlocks(available || []);
                    setLoadedBlockIds(profile?.loadedBlocks || []);
                } catch (error) {
                    console.error('Error loading available blocks:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleLoadBlock = async (blockId) => {
                setLoadingActions(prev => ({ ...prev, [blockId]: 'loading' }));
                try {
                    await window.apiDataService.loadBlock(blockId);
                    setMessage('Bloque cargado exitosamente');
                    await loadData(); // Refresh blocks data
                    // Also refresh games data since available questions may have changed
                    if (window.refreshActiveGamesData) {
                        await window.refreshActiveGamesData();
                    }
                    // Refresh game configuration dashboard as well
                    if (window.refreshPlayerDashboardData) {
                        await window.refreshPlayerDashboardData();
                    }
                } catch (error) {
                    console.error('Error loading block:', error);
                    setMessage('Error al cargar el bloque');
                } finally {
                    setLoadingActions(prev => ({ ...prev, [blockId]: null }));
                    setTimeout(() => setMessage(''), 3000);
                }
            };

            const handleUnloadBlock = async (blockId) => {
                setLoadingActions(prev => ({ ...prev, [blockId]: 'unloading' }));
                try {
                    await window.apiDataService.unloadBlock(blockId);
                    setMessage('Bloque descargado exitosamente');
                    await loadData(); // Refresh blocks data
                    // Also refresh games data since available questions may have changed
                    if (window.refreshActiveGamesData) {
                        await window.refreshActiveGamesData();
                    }
                    // Refresh game configuration dashboard as well
                    if (window.refreshPlayerDashboardData) {
                        await window.refreshPlayerDashboardData();
                    }
                } catch (error) {
                    console.error('Error unloading block:', error);
                    setMessage('Error al descargar el bloque');
                } finally {
                    setLoadingActions(prev => ({ ...prev, [blockId]: null }));
                    setTimeout(() => setMessage(''), 3000);
                }
            };

            const loadMetadata = async () => {
                try {
                    console.log('🔍 Loading metadata for filters...');
                    const metadata = await window.apiDataService.fetchBlockMetadata();
                    console.log('✅ Loaded metadata:', metadata);
                    setBlockMetadata(metadata);
                } catch (error) {
                    console.error('❌ Error loading metadata for filters:', error);
                }
            };

            const applyFilters = () => {
                if (!availableBlocks.length) {
                    setFilteredBlocks([]);
                    return;
                }

                let filtered = availableBlocks.filter(block =>
                    block.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    block.creatorNickname?.toLowerCase().includes(searchTerm.toLowerCase())
                );

                // Aplicar filtros de metadata
                if (selectedTipo) {
                    filtered = filtered.filter(block => block.tipo_id == selectedTipo);
                }
                
                if (selectedNivel) {
                    filtered = filtered.filter(block => block.nivel_id == selectedNivel);
                }
                
                if (selectedEstado) {
                    filtered = filtered.filter(block => block.estado_id == selectedEstado);
                }

                console.log(`🔍 Filtered ${filtered.length} blocks from ${availableBlocks.length} total`);
                setFilteredBlocks(filtered);
            };

            const clearFilters = () => {
                console.log('🗑️ Clearing all filters');
                setSearchTerm('');
                setSelectedTipo('');
                setSelectedNivel('');
                setSelectedEstado('');
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando bloques disponibles...')
                ]);
            }

            return React.createElement('div', { className: "bg-slate-800 p-6 rounded-xl shadow-lg" }, [
                // Message display
                message && React.createElement('div', {
                    key: 'message',
                    className: `mb-4 p-3 rounded-lg text-center ${message.includes('Error') ? 'bg-red-500/20 text-red-300' : 'bg-green-500/20 text-green-300'}`
                }, message),

                // Search bar
                React.createElement('div', {
                    key: 'search-container',
                    className: "mb-6"
                }, React.createElement('div', {
                    className: "relative"
                }, [
                    React.createElement('input', {
                        key: 'search-input',
                        type: "text",
                        placeholder: "Buscar bloques...",
                        value: searchTerm,
                        onChange: (e) => setSearchTerm(e.target.value),
                        className: "w-full px-4 py-2 pl-10 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-blue-500"
                    }),
                    React.createElement('svg', {
                        key: 'search-icon',
                        className: "absolute left-3 top-3 h-4 w-4 text-gray-400",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                    }, React.createElement('path', {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                    }))
                ])),

                // Filtros de Metadata
                React.createElement('div', {
                    key: 'metadata-filters',
                    className: "mb-6 p-4 bg-slate-700 rounded-lg border border-slate-600"
                }, [
                    React.createElement('h4', {
                        key: 'filters-title',
                        className: "text-sm font-medium text-gray-300 mb-3"
                    }, '🔍 Filtros'),
                    
                    React.createElement('div', {
                        key: 'filters-grid',
                        className: "grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4"
                    }, [
                        // Filtro Tipo
                        React.createElement('div', { key: 'tipo-filter' }, [
                            React.createElement('label', {
                                key: 'tipo-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Tipo de Bloque'),
                            React.createElement('select', {
                                key: 'tipo-select',
                                value: selectedTipo,
                                onChange: (e) => setSelectedTipo(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'tipo-all', value: '' }, 'Todos los tipos'),
                                ...blockMetadata.types.map(tipo => 
                                    React.createElement('option', { key: `tipo-${tipo.id}`, value: tipo.id }, tipo.name)
                                )
                            ])
                        ]),
                        
                        // Filtro Nivel
                        React.createElement('div', { key: 'nivel-filter' }, [
                            React.createElement('label', {
                                key: 'nivel-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Nivel'),
                            React.createElement('select', {
                                key: 'nivel-select',
                                value: selectedNivel,
                                onChange: (e) => setSelectedNivel(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'nivel-all', value: '' }, 'Todos los niveles'),
                                ...blockMetadata.levels.map(nivel => 
                                    React.createElement('option', { key: `nivel-${nivel.id}`, value: nivel.id }, nivel.name)
                                )
                            ])
                        ]),
                        
                        // Filtro Carácter/Estado
                        React.createElement('div', { key: 'estado-filter' }, [
                            React.createElement('label', {
                                key: 'estado-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Carácter'),
                            React.createElement('select', {
                                key: 'estado-select',
                                value: selectedEstado,
                                onChange: (e) => setSelectedEstado(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'estado-all', value: '' }, 'Todos los caracteres'),
                                ...blockMetadata.states.map(estado => 
                                    React.createElement('option', { key: `estado-${estado.id}`, value: estado.id }, estado.name)
                                )
                            ])
                        ]),
                        
                        // Botón limpiar filtros
                        React.createElement('div', { key: 'clear-filter-container', className: "flex items-end" }, [
                            React.createElement('button', {
                                key: 'clear-filters-btn',
                                onClick: clearFilters,
                                className: "w-full px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-red-500"
                            }, '🗑️ Limpiar')
                        ])
                    ])
                ]),

                // Blocks grid
                filteredBlocks.length === 0 ? React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-12"
                }, React.createElement('p', {
                    className: "text-gray-400 text-lg"
                }, searchTerm ? 'No se encontraron bloques que coincidan con la búsqueda' : 'No hay bloques disponibles')) : 
                React.createElement('div', {
                    key: 'blocks-grid',
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                }, filteredBlocks.map(block => {
                    const isLoaded = loadedBlockIds.includes(block.id);
                    const actionLoading = loadingActions[block.id];
                    
                    return React.createElement('div', {
                        key: block.id,
                        className: "bg-slate-700 p-4 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors"
                    }, [
                        React.createElement('div', {
                            key: 'block-header',
                            className: "flex justify-between items-start mb-3"
                        }, [
                            React.createElement('h3', {
                                key: 'block-name',
                                className: "font-semibold text-white text-lg leading-tight pr-2"
                            }, block.name),
                            isLoaded && React.createElement('span', {
                                key: 'loaded-badge',
                                className: "text-xs bg-green-500/20 text-green-300 px-2 py-1 rounded-full flex-shrink-0"
                            }, 'Cargado')
                        ]),
                        
                        React.createElement('p', {
                            key: 'block-description',
                            className: "text-gray-400 text-sm mb-3 line-clamp-2"
                        }, block.description || 'Sin descripción'),
                        
                        React.createElement('div', {
                            key: 'block-info',
                            className: "flex justify-between items-center mb-4 text-xs text-gray-500"
                        }, [
                            React.createElement('span', {
                                key: 'questions-count'
                            }, `${block.questionCount || 0} preguntas`),
                            React.createElement('span', {
                                key: 'creator'
                            }, `por ${block.creatorNickname || 'Usuario'}`)
                        ]),
                        
                        React.createElement('button', {
                            key: 'action-button',
                            onClick: () => isLoaded ? handleUnloadBlock(block.id) : handleLoadBlock(block.id),
                            disabled: !!actionLoading,
                            className: `w-full py-2 px-4 rounded-md font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${
                                isLoaded
                                    ? 'bg-red-500/20 text-red-300 hover:bg-red-500/30'
                                    : 'bg-blue-600 hover:bg-blue-700 text-white'
                            }`
                        }, actionLoading ? React.createElement('div', {
                            className: "flex items-center justify-center"
                        }, [
                            React.createElement('div', {
                                key: 'action-spinner',
                                className: "animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"
                            }),
                            actionLoading === 'loading' ? 'Cargando...' : 'Descargando...'
                        ]) : (isLoaded ? 'Descargar' : 'Cargar'))
                    ]);
                }))
            ]);
        };

        // Componente ActiveGames separado para la sección Juegos Activos  
        const ActiveGamesComponent = () => {
            const [games, setGames] = useState([]);
            const [gameConfigurations, setGameConfigurations] = useState([]);
            const [challenges, setChallenges] = useState([]);
            const [blocks, setBlocks] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [currentUser, setCurrentUser] = useState(null);

            const loadActiveGamesData = async () => {
                try {
                    setIsLoading(true);
                    const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                    
                    if (!window.apiDataService) {
                        setTimeout(loadActiveGamesData, 1000);
                        return;
                    }
                    
                    const userId = session.id || session.userId;
                    if (!userId) {
                        return;
                    }

                    setCurrentUser(session);
                    
                    const [gamesData, configurations, challengesData, blocksData] = await Promise.all([
                        window.apiDataService.fetchGamesForUser(userId),
                        window.apiDataService.fetchGameConfigurations(userId),
                        window.apiDataService.fetchChallengesForUser(userId),
                        window.apiDataService.fetchLoadedBlocks()
                    ]);
                    
                    setGames(gamesData || []);
                    setGameConfigurations(configurations || []);
                    setChallenges(challengesData || []);
                    setBlocks(blocksData || []);
                } catch (error) {
                    console.error('Error loading active games data:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            useEffect(() => {
                loadActiveGamesData();
                // Make refresh function available globally
                window.refreshActiveGamesData = loadActiveGamesData;
            }, []);

            const onNavigateToGame = (game) => {
                const isInProgress = (game.mode === 'Duelo' || game.mode === 'Trivial') && 
                    (game.gameState || game.turnState || (game.round && game.round > 0));

                if (isInProgress) {
                    const targetPage = game.mode === 'Duelo' ? 'game-duel.html' : 'game-trivial.html';
                    window.location.href = `${targetPage}?gameId=${game.id}`;
                } else {
                    window.location.href = `active-game.html?gameId=${game.id}`;
                }
            };

            const handleDeleteGame = async (gameId) => {
                try {
                    if (window.apiDataService && currentUser) {
                        const userId = currentUser.id || currentUser.userId;
                        await window.apiDataService.deleteGameForUser(userId, gameId);
                        setGames(prev => prev.filter(g => g.id !== gameId));
                    }
                } catch (error) {
                    console.error('Error deleting game:', error);
                }
            };

            const handleAcceptChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        // Recargar datos
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);
                        setGames(gamesData || []);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('Error accepting challenge:', error);
                }
            };

            const handleDeclineChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.declineChallenge(currentUser.id, challengeId);
                        // Recargar datos
                        const challengesData = await window.apiDataService.fetchChallengesForUser(currentUser.id);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('Error declining challenge:', error);
                }
            };

            // Enhanced decline with reason for ActiveGamesComponent
            const handleDeclineWithReason = async (challengeId, challengerNickname) => {
                const reason = prompt(
                    `¿Por qué declinas el reto de ${challengerNickname}?\n\n(Opcional: Puedes dejar este campo vacío o escribir una razón que será enviada al retador)`
                );
                
                // Allow cancellation
                if (reason === null) return;
                
                try {
                    if (window.apiDataService) {
                        console.log('❌ Declining challenge with reason:', { challengeId, reason });
                        
                        // Send decline with reason to backend
                        await window.apiDataService.declineChallengeWithReason(currentUser.id, challengeId, reason || '');
                        
                        // Recargar datos
                        const challengesData = await window.apiDataService.fetchChallengesForUser(currentUser.id);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('❌ Error declining challenge with reason:', error);
                }
            };

            // Enhanced accept to start game for ActiveGamesComponent  
            const handleAcceptAndStartGame = async (challengeId, challenge) => {
                try {
                    if (window.apiDataService && onNavigateToGame) {
                        console.log('🎮 Accepting challenge and starting game:', { challengeId, challenge });
                        
                        // Accept the challenge (this changes status from 'pending' to 'active')
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        
                        // Navigate directly to the game with the challenge's game ID
                        console.log('🚀 Redirecting to game:', challengeId);
                        onNavigateToGame(challengeId);
                        
                        // Refresh data to remove the challenge from pending list
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);
                        setGames(gamesData || []);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('❌ Error accepting challenge and starting game:', error);
                }
            };

            const handleDeleteConfiguration = async (configId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameConfiguration(configId);
                        const configurations = await window.apiDataService.fetchGameConfigurations(currentUser.id);
                        setGameConfigurations(configurations || []);
                    }
                } catch (error) {
                    console.error('Error deleting configuration:', error);
                }
            };

            const handleRepeatConfiguration = async (config) => {
                try {
                    if (window.apiDataService && currentUser) {
                        const gameConfig = { 
                            mode: config.game_type || config.gameType || 'Partida', 
                            config: config.configuration || config.config 
                        };
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (error) {
                    console.error('Error repeating configuration:', error);
                }
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando juegos activos...')
                ]);
            }

            return React.createElement(ActiveGames, {
                games: games,
                gameConfigurations: gameConfigurations,
                challenges: challenges,
                blocks: blocks,
                onDeleteGame: handleDeleteGame,
                onNavigateToGame: onNavigateToGame,
                onAcceptChallenge: handleAcceptChallenge,
                onDeclineChallenge: handleDeclineChallenge,
                handleDeleteConfiguration: handleDeleteConfiguration,
                onRepeatConfiguration: handleRepeatConfiguration,
                setCurrentView: () => {}
            });
        };

        const TabHistoryComponent = () => {
            const [tabGameHistory, setTabGameHistory] = useState([]);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const loadHistory = async () => {
                    try {
                        setIsLoading(true);
                        const currentUser = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                        
                        if (!window.apiDataService) {
                            setTimeout(loadHistory, 1000);
                            return;
                        }
                        
                        const userId = currentUser.id || currentUser.userId;
                        if (!userId) {
                            return;
                        }

                        const history = await window.apiDataService.fetchGameHistory(userId);
                        setTabGameHistory(history || []);
                    } catch (error) {
                        console.error('Error loading game history:', error);
                    } finally {
                        setIsLoading(false);
                    }
                };
                loadHistory();
            }, []);

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando historial...')
                ]);
            }

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                tabGameHistory && tabGameHistory.length > 0 ? React.createElement('div', {
                    key: 'history-table-container',
                    className: "overflow-x-auto flex-grow"
                }, React.createElement('table', {
                    key: 'history-table',
                    className: "w-full text-sm"
                }, [
                    React.createElement('thead', { key: 'thead' }, React.createElement('tr', {
                        key: 'header-row',
                        className: "border-b border-slate-600"
                    }, [
                        React.createElement('th', { key: 'block-header', className: "py-2 px-2 text-left text-gray-300 font-semibold truncate" }, 'Bloque'),
                        React.createElement('th', { key: 'mode-header', className: "py-2 px-2 text-left text-gray-300 font-semibold" }, 'Modo'),
                        React.createElement('th', { key: 'score-header', className: "py-2 px-2 text-center text-gray-300 font-semibold" }, 'Punt.'),
                        React.createElement('th', { key: 'date-header', className: "py-2 px-2 text-left text-gray-300 font-semibold" }, 'Fecha')
                    ])),
                    React.createElement('tbody', { key: 'tbody' }, tabGameHistory.map((game, index) =>
                        React.createElement('tr', {
                            key: `game-${game.gameId || index}-${game.date || Date.now()}-${index}`,
                            className: "border-b border-slate-600"
                        }, [
                            React.createElement('td', {
                                key: 'block-name',
                                className: "py-3 px-2 font-medium text-white truncate max-w-32",
                                title: game.blockName
                            }, game.blockName),
                            React.createElement('td', { key: 'mode-info', className: "py-3 px-2 text-gray-400" }, [
                                React.createElement('div', { key: 'game-mode', className: "font-medium text-white" }, game.gameMode || 'Clásico'),
                                React.createElement('div', { key: 'config-info', className: "text-xs" }, `${game.totalQuestions || 0} preguntas`)
                            ]),
                            React.createElement('td', { key: 'score-cell', className: "py-3 px-2 text-center" }, React.createElement('span', {
                                key: 'score-value',
                                className: "font-bold px-2 py-1 rounded text-xs",
                                style: { color: game.score >= 5 ? '#10B981' : '#EF4444' }
                            }, game.score || 0)),
                            React.createElement('td', { key: 'date-cell', className: "py-3 px-2 text-gray-400 text-xs" }, (() => {
                                const date = new Date(game.createdAt || Date.now());
                                return `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                            })())
                        ])
                    ))
                ])) : React.createElement('div', {
                    key: 'no-history',
                    className: "text-center text-gray-400 py-8"
                }, 'No hay historial de partidas')
            ]);
        };

        // Datos globales para los bloques disponibles
        let availableBlocksData = [];
        let availableBlocksMetadata = null;

        // Crear componente de Bloques Disponibles mejorado con filtros
        const createAvailableBlocksComponent = async () => {
            const container = document.getElementById('available-blocks-pjg-container');
            if (!container || !window.apiDataService) return;

            try {
                // Mostrar loading
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #778DA9;">
                        <div style="animation: spin 1s linear infinite; border: 2px solid #415A77; border-top: 2px solid #3B82F6; border-radius: 50%; width: 40px; height: 40px; margin: 0 auto 20px;"></div>
                        <p>Cargando bloques disponibles...</p>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;

                // Cargar datos en paralelo
                const [blocks, profile, metadata] = await Promise.all([
                    window.apiDataService.fetchAvailableBlocks(),
                    window.apiDataService.getUserProfile(),
                    window.apiDataService.fetchBlockMetadata()
                ]);
                
                availableBlocksData = blocks;
                availableBlocksMetadata = metadata;
                const loadedBlockIds = profile.loadedBlocks || [];

                // Renderizar estructura con filtros
                container.innerHTML = `
                    <!-- Filtros de Metadata -->
                    <div class="ab-filters" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; padding: 15px; background: #0F172A; border-radius: 8px; border: 1px solid #334155;">
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Tipo de Bloque:</label>
                            <select id="ab-filter-tipo" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los tipos</option>
                            </select>
                        </div>
                        
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Nivel:</label>
                            <select id="ab-filter-nivel" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los niveles</option>
                            </select>
                        </div>
                        
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Carácter:</label>
                            <select id="ab-filter-caracter" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los caracteres</option>
                            </select>
                        </div>
                        
                        <button onclick="clearAvailableBlocksFilters()" style="background: #DC2626; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; height: fit-content; margin-top: auto; transition: background 0.3s ease;">
                            🗑️ Limpiar Filtros
                        </button>
                    </div>
                    
                    <div id="available-blocks-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px;">
                        <!-- Los bloques se cargarán aquí -->
                    </div>
                `;

                // Poblar filtros con metadata
                populateAvailableBlocksFilters(metadata);
                
                // Mostrar todos los bloques inicialmente
                displayAvailableBlocks(blocks, loadedBlockIds);

                // Función para manejar acciones de carga/descarga
                window.handleBlockAction = async (blockId, isLoaded) => {
                    try {
                        if (isLoaded) {
                            await window.apiDataService.unloadBlockForUser(blockId);
                        } else {
                            await window.apiDataService.loadBlockForUser(blockId);
                        }
                        // Recargar datos y actualizar la vista manteniendo filtros aplicados
                        const [updatedBlocks, updatedProfile] = await Promise.all([
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);
                        
                        availableBlocksData = updatedBlocks;
                        
                        // Aplicar los filtros actuales a los nuevos datos
                        const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
                        const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
                        const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
                        
                        let filteredBlocks = [...availableBlocksData];
                        
                        if (tipoFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
                        }
                        
                        if (nivelFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
                        }
                        
                        if (caracterFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
                        }
                        
                        await displayAvailableBlocks(filteredBlocks, updatedProfile.loadedBlocks);
                        
                        // 🔄 Refrescar también el componente de Bloques Cargados
                        console.log('🔄 [PJG] Refreshing loaded blocks component after block action...');
                        if (window.bloquesCreados_loaded_blocks_pjg_container && typeof window.bloquesCreados_loaded_blocks_pjg_container.refresh === 'function') {
                            console.log('🔄 Refreshing bloquesCreados_loaded_blocks_pjg_container...');
                            window.bloquesCreados_loaded_blocks_pjg_container.refresh();
                            console.log('✅ Loaded blocks component refreshed successfully');
                        } else {
                            console.log('ℹ️ Loaded blocks component not available for refresh');
                        }
                        
                    } catch (error) {
                        console.error('Error handling block action:', error);
                        alert('Error al procesar la acción. Inténtalo de nuevo.');
                    }
                };

                // 🔄 Función para refrescar solo "Bloques Disponibles" después de descargar desde "Bloques Cargados"
                window.refreshAvailableBlocksAfterUnload = async () => {
                    console.log('🔄 [PJG] Refreshing Available Blocks after unload from Loaded Blocks...');
                    try {
                        // Recargar datos de bloques disponibles
                        const [updatedBlocks, updatedProfile] = await Promise.all([
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);
                        
                        availableBlocksData = updatedBlocks;
                        
                        // Aplicar los filtros actuales a los nuevos datos
                        const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
                        const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
                        const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
                        
                        let filteredBlocks = [...availableBlocksData];
                        
                        if (tipoFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
                        }
                        
                        if (nivelFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
                        }
                        
                        if (caracterFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
                        }
                        
                        await displayAvailableBlocks(filteredBlocks, updatedProfile.loadedBlocks);
                        console.log('✅ [PJG] Available Blocks refreshed after unload');
                        
                    } catch (error) {
                        console.error('❌ Error refreshing available blocks after unload:', error);
                    }
                };

                // Función para ver el contenido de bloques disponibles
                window.viewAvailableBlockContent = async (blockId, blockName, isLoaded) => {
                    try {
                        // Crear contenedor para el viewer si no existe
                        let viewerContainer = document.getElementById('available-blocks-content-viewer');
                        if (!viewerContainer) {
                            viewerContainer = document.createElement('div');
                            viewerContainer.id = 'available-blocks-content-viewer';
                            viewerContainer.style.display = 'none';
                            document.getElementById('available-blocks-pjg-container').parentNode.appendChild(viewerContainer);
                        }

                        // Ocultar la lista de bloques disponibles y mostrar el viewer
                        document.getElementById('available-blocks-pjg-container').style.display = 'none';
                        viewerContainer.style.display = 'block';

                        // Crear una instancia temporal del componente BloquesCreados para el viewer
                        if (typeof BloquesCreados !== 'undefined') {
                            viewerContainer.innerHTML = '<div id="temp-available-block-viewer"></div>';
                            
                            const tempViewer = new BloquesCreados('temp-available-block-viewer', 'estudiantes', 'available');
                            tempViewer.initialize().then(() => {
                                // Cargar directamente el contenido del bloque
                                tempViewer.loadBlockContentViewer(blockId, blockName);
                            });

                            // Actualizar el botón de cierre para volver a la lista de disponibles
                            const checkAndUpdateCloseButton = () => {
                                const closeButton = document.querySelector('#temp-available-block-viewer .bc-btn-close');
                                if (closeButton) {
                                    closeButton.onclick = () => {
                                        viewerContainer.style.display = 'none';
                                        document.getElementById('available-blocks-pjg-container').style.display = 'block';
                                    };
                                } else {
                                    setTimeout(checkAndUpdateCloseButton, 100);
                                }
                            };
                            checkAndUpdateCloseButton();

                        } else {
                            alert('Error: BloquesCreados component not available');
                        }
                    } catch (error) {
                        console.error('Error viewing block content:', error);
                        alert('Error al cargar el contenido del bloque.');
                    }
                };

            } catch (error) {
                console.error('Error loading available blocks:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #EF4444;">
                        <p>Error al cargar los bloques disponibles</p>
                        <button onclick="createAvailableBlocksComponent()" style="margin-top: 10px; padding: 8px 16px; background: #3B82F6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Reintentar
                        </button>
                    </div>
                `;
            }
        };

        // Función para poblar los filtros de bloques disponibles
        const populateAvailableBlocksFilters = (metadata) => {
            const tipoSelect = document.getElementById('ab-filter-tipo');
            const nivelSelect = document.getElementById('ab-filter-nivel');
            const caracterSelect = document.getElementById('ab-filter-caracter');
            
            // Poblar filtros de tipo
            if (tipoSelect && metadata.types) {
                metadata.types.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo.id;
                    option.textContent = tipo.name;
                    tipoSelect.appendChild(option);
                });
            }
            
            // Poblar filtros de nivel
            if (nivelSelect && metadata.levels) {
                metadata.levels.forEach(nivel => {
                    const option = document.createElement('option');
                    option.value = nivel.id;
                    option.textContent = nivel.name;
                    nivelSelect.appendChild(option);
                });
            }
            
            // Poblar filtros de carácter (estado)
            if (caracterSelect && metadata.states) {
                metadata.states.forEach(estado => {
                    const option = document.createElement('option');
                    option.value = estado.id;
                    option.textContent = estado.name;
                    caracterSelect.appendChild(option);
                });
            }
        };

        // Función para mostrar bloques disponibles
        const displayAvailableBlocks = async (blocks, loadedBlockIds) => {
            const grid = document.getElementById('available-blocks-grid');
            if (!grid) return;
            
            // Obtener perfil actualizado si no se proporciona loadedBlockIds
            if (!loadedBlockIds) {
                const profile = await window.apiDataService.getUserProfile();
                loadedBlockIds = profile.loadedBlocks || [];
            }
            
            const blocksHTML = blocks.map(block => {
                const isLoaded = loadedBlockIds.includes(block.id);
                return `
                    <div style="background: #0F172A; border: 1px solid #334155; border-radius: 8px; padding: 24px; transition: all 0.3s ease; min-height: 200px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                            <h3 onclick="viewAvailableBlockContent(${block.id}, '${block.name}', ${isLoaded})" 
                                style="font-size: 16px; font-weight: 600; color: #E0E7FF; margin: 0; flex: 1; line-height: 1.25; cursor: pointer; transition: color 0.3s ease;" 
                                onmouseover="this.style.color='#3B82F6'; this.style.textDecoration='underline';" 
                                onmouseout="this.style.color='#E0E7FF'; this.style.textDecoration='none';">${block.name}</h3>
                            ${isLoaded ? '<span style="font-size: 12px; background: rgba(16, 185, 129, 0.2); color: #10B981; padding: 4px 8px; border-radius: 12px;">Cargado</span>' : ''}
                        </div>
                        
                        <p style="color: #CBD5E1; font-size: 14px; margin-bottom: 12px; line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;">
                            ${block.description || 'Sin descripción'}
                        </p>
                        
                        ${block.metadata ? `
                        <div style="margin-bottom: 12px; font-size: 12px; color: #94A3B8; display: flex; flex-wrap: wrap; gap: 8px 16px; background: #1E293B; padding: 8px; border-radius: 6px;">
                            <span><strong>Tipo:</strong> ${block.metadata.tipo || 'N/A'}</span>
                            <span><strong>Nivel:</strong> ${block.metadata.nivel || 'N/A'}</span>
                            <span><strong>Estado:</strong> ${block.metadata.estado || 'N/A'}</span>
                        </div>
                        ` : ''}
                        
                        <div style="margin-bottom: 16px; font-size: 13px; color: #CBD5E1; display: flex; flex-wrap: wrap; gap: 8px 16px;">
                            <span><strong>Preguntas:</strong> ${block.questionCount || 0}</span>
                            <span><strong>Temas:</strong> ${block.stats?.totalTopics || 0}</span>
                            <span><strong>Usuarios:</strong> ${block.stats?.totalUsers || 0}</span>
                            <span><strong>Creador:</strong> ${block.creatorNickname || 'Usuario'}</span>
                        </div>
                        
                        <button onclick="handleBlockAction(${block.id}, ${isLoaded})" 
                            style="width: 100%; padding: 10px 16px; border-radius: 6px; font-weight: 500; transition: all 0.3s ease; border: none; cursor: pointer; 
                            ${isLoaded 
                                ? 'background: rgba(239, 68, 68, 0.2); color: #EF4444;' 
                                : 'background: #3B82F6; color: white;'
                            }">
                            ${isLoaded ? 'Descargar' : 'Cargar'}
                        </button>
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = blocksHTML;
        };

        // Función para aplicar filtros a bloques disponibles
        const applyAvailableBlocksFilters = async () => {
            const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
            const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
            const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
            
            console.log('🔍 Applying available blocks filters:', { tipoFilter, nivelFilter, caracterFilter });
            
            if (!availableBlocksData || availableBlocksData.length === 0) {
                console.log('❌ No available blocks data for filtering');
                return;
            }
            
            let filteredBlocks = [...availableBlocksData];
            
            // Aplicar filtros
            if (tipoFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
            }
            
            if (nivelFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
            }
            
            if (caracterFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
            }
            
            console.log(`✅ Filtered available blocks: ${filteredBlocks.length} from ${availableBlocksData.length} total`);
            
            // Mostrar bloques filtrados
            await displayAvailableBlocks(filteredBlocks);
        };

        // Función para limpiar filtros de bloques disponibles
        const clearAvailableBlocksFilters = async () => {
            console.log('🗑️ Clearing available blocks filters');
            
            document.getElementById('ab-filter-tipo').value = '';
            document.getElementById('ab-filter-nivel').value = '';
            document.getElementById('ab-filter-caracter').value = '';
            
            await displayAvailableBlocks(availableBlocksData);
        };

        // Renderizar componentes específicos en pestañas después de que React esté disponible
        const initializeTabComponents = () => {
            // Inicializar Bloques Cargados con el componente actualizado
            if (document.getElementById('loaded-blocks-pjg-container')) {
                // Esperar a que BloquesCreados esté disponible
                const initLoadedBlocks = () => {
                    if (typeof BloquesCreados !== 'undefined') {
                        window.bloquesCreados_loaded_blocks_pjg_container = new BloquesCreados('loaded-blocks-pjg-container', 'estudiantes', 'loaded');
                        window.bloquesCreados_loaded_blocks_pjg_container.initialize();
                    } else {
                        setTimeout(initLoadedBlocks, 500);
                    }
                };
                initLoadedBlocks();
            }

            // Inicializar Bloques Disponibles con componente mejorado
            if (document.getElementById('available-blocks-pjg-container')) {
                createAvailableBlocksComponent();
            }

            // Renderizar Juegos Activos COMPLETO en su sección
            const activeGamesContainer = document.getElementById('active-games-content');
            if (activeGamesContainer) {
                const activeGamesRoot = ReactDOM.createRoot(activeGamesContainer);
                activeGamesRoot.render(
                    React.createElement(LanguageProvider, {}, 
                        React.createElement(UserContext.Provider, { value: { currentUser: JSON.parse(localStorage.getItem('playtest_session') || '{}') } },
                            React.createElement(ActiveGamesComponent)
                        )
                    )
                );
            }

            // Renderizar Historial de Partidas COMPLETO en su pestaña
            const gameHistoryContainer = document.getElementById('games-history-content');
            if (gameHistoryContainer) {
                const gameHistoryRoot = ReactDOM.createRoot(gameHistoryContainer);
                gameHistoryRoot.render(
                    React.createElement(LanguageProvider, {}, 
                        React.createElement(UserContext.Provider, { value: { currentUser: JSON.parse(localStorage.getItem('playtest_session') || '{}') } },
                            React.createElement(TabHistoryComponent)
                        )
                    )
                );
            }
        };

        // Ejecutar cuando el DOM y apiDataService estén disponibles
        const waitForApiAndInitialize = () => {
            if (window.apiDataService) {
                initializeTabComponents();
            } else {
                setTimeout(waitForApiAndInitialize, 1000);
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForApiAndInitialize);
        } else {
            waitForApiAndInitialize();
        }

        // Función para cambiar entre pestañas
        window.switchTab = function(tabName) {
            // Ocultar todos los contenidos de pestañas
            const allTabContents = document.querySelectorAll('.tab-content');
            allTabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Desactivar todos los botones de pestaña
            const allTabButtons = document.querySelectorAll('.tab-button');
            allTabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Mostrar el contenido de la pestaña seleccionada
            const selectedTab = document.getElementById(tabName + '-tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Activar el botón de la pestaña seleccionada
            const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
        };
    </script>

    <!-- Los modales se cargan dinámicamente con el header-component (SIN modales de Explicación del Juego) -->
</body>
</html>