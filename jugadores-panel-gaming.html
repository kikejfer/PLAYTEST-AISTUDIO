<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="panel-type" content="PJG">
    <meta name="header-container" content="header-container">
    <title>Panel Jugador - PLAYTEST</title>
    
    <!-- Estilos del header unificado -->
    <link rel="stylesheet" href="header-styles.css?v=20251026h">
    <script src="header-loader.js?v=20251026h"></script>
    <script src="api-data-service.js?v=20251026h"></script>
    <script src="bloques-creados-component.js?v=20251026h"></script>
    
    <!-- CDN de React y Babel para compatibilidad con el c√≥digo de index.html -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Anular header original de index.html */
        .original-header,
        .index-header,
        header.bg-brand-secondary {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            overflow: hidden !important;
        }

        /* Estilos adicionales para el panel */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0D1B2A;
            min-height: 100vh;
            color: #E0E1DD;
            padding-top: 100px; /* Espacio para header unificado */
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Variables CSS para compatibilidad con Tailwind */
        :root {
            --brand-primary: #0D1B2A;
            --brand-secondary: #1B263B;
            --brand-tertiary: #415A77;
            --brand-accent: #778DA9;
            --brand-light: #E0E1DD;
            --brand-cta: #3B82F6;
            --brand-cta-hover: #2563EB;
            --brand-success: #10B981;
            --brand-danger: #EF4444;
        }

        /* Panel Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 1px solid #415A77;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: #E0E1DD;
            margin: 0;
        }

        /* Tabs Styles */
        .tabs-container {
            background: #1B263B;
            border: 1px solid #415A77;
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .tabs-nav {
            display: flex;
            border-bottom: 1px solid #415A77;
            overflow-x: auto;
        }

        .tab-button {
            flex: none;
            padding: 15px 25px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #778DA9;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: fit-content;
        }

        .tab-button.active {
            color: #E0E1DD;
            background: #415A77;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .tab-button:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #3B82F6;
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
        }

        /* Section Styles */
        .section {
            background: #1B263B;
            border: 1px solid #415A77;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .section-title {
            background: #415A77;
            color: #E0E1DD;
            padding: 15px 20px;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            border-radius: 10px 10px 0 0;
            border-bottom: 1px solid #778DA9;
        }

        .section-content {
            padding: 20px;
        }

        /* Search Input */
        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #415A77;
            border-radius: 6px;
            background: #0D1B2A;
            color: #E0E1DD;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
    </style>
</head>
<body>
    <!-- Contenedor del header unificado -->
    <div id="header-container"></div>

    <!-- Contenido principal del panel de jugadores -->
    <div class="container">
        <div class="header">
            <p>Plataforma completa para jugar, gestionar bloques de contenido y revisar tu progreso acad√©mico.</p>
        </div>

        <div class="tabs-container">
            <div class="tabs-nav">
                <button class="tab-button active" onclick="switchTab('partidas')">üéÆ Partidas</button>
                <button class="tab-button" onclick="switchTab('bloques')">üìö Marketplace</button>
                <button class="tab-button" id="mis-clases-tab-button" onclick="switchTab('mis-clases')">üéì Mis Clases</button>
                <button class="tab-button" onclick="switchTab('historico')">üìä Hist√≥rico</button>
            </div>
        </div>

        <!-- Pesta√±a Partidas -->
        <div id="partidas-tab" class="tab-content active">
            <!-- Secci√≥n Configuraci√≥n de Partida -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Config.png" alt="Config" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Configuraci√≥n de Partida</h2>
                <div class="section-content">
                    <div id="player-dashboard-root"></div>
                </div>
            </div>

            <!-- Secci√≥n Juegos Activos -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Juegos.png" alt="Juegos" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Juegos Activos</h2>
                <div class="section-content">
                    <div id="active-games-content"></div>
                </div>
            </div>
        </div>

        <!-- Pesta√±a Carga de Bloques -->
        <div id="bloques-tab" class="tab-content">
            <!-- Secci√≥n Bloques Cargados - Usando componente completo -->
            <div id="loaded-blocks-pjg-container"></div>

            <!-- Secci√≥n Bloques Disponibles -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Disponibles.png" alt="Disponibles" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Bloques Disponibles</h2>
                <div class="section-content">
                    <div id="available-blocks-pjg-container"></div>
                </div>
            </div>
        </div>

        <!-- Pesta√±a Hist√≥rico -->
        <div id="historico-tab" class="tab-content">
            <!-- Secci√≥n Historial de Partidas -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Historia.png" alt="Historia" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Historial de Partidas</h2>
                <div class="section-content">
                    <div id="games-history-content"></div>
                </div>
            </div>

            <!-- Secci√≥n Rankings Globales -->
            <div class="section">
                <h2 class="section-title"><img src="./Imagenes/Ranking.png" alt="Ranking" style="height: 24px; width: 24px; display: inline-block; margin-right: 8px;"> Rankings Globales</h2>
                <div class="section-content">
                    <div id="global-rankings-content"></div>
                </div>
            </div>

            <!-- Secci√≥n Estad√≠sticas -->
            <div class="section">
                <h2 class="section-title">üìä Estad√≠sticas</h2>
                <div class="section-content">
                    <div id="statistics-content"></div>
                </div>
            </div>
        </div>

        <!-- Pesta√±a Mis Clases -->
        <div id="mis-clases-tab" class="tab-content">
            <!-- Secci√≥n Inscripci√≥n a Clase -->
            <div class="section" id="enrollment-section">
                <h2 class="section-title">üéì √önete a una Clase</h2>
                <div class="section-content">
                    <p style="color: #778DA9; margin-bottom: 20px;">
                        Si tu profesor te ha dado un c√≥digo de clase, ingr√©salo aqu√≠ para acceder a los bloques asignados.
                    </p>
                    <div style="display: flex; gap: 10px; max-width: 500px;">
                        <input
                            type="text"
                            id="class-code-input"
                            placeholder="Ingresa el c√≥digo de clase (ej: MATH2024-A)"
                            class="search-input"
                            style="flex: 1;"
                        >
                        <button class="btn btn-primary" onclick="enrollInClass()" style="background: #10B981;">
                            Inscribirme
                        </button>
                    </div>
                    <p id="enrollment-message" style="margin-top: 15px; color: #10B981; display: none;"></p>
                </div>
            </div>

            <!-- Secci√≥n Mis Clases -->
            <div class="section">
                <h2 class="section-title">üìö Mis Clases</h2>
                <div class="section-content">
                    <div id="my-classes-container">
                        <div class="loading">Cargando tus clases...</div>
                    </div>
                </div>
            </div>

            <!-- Secci√≥n Mis Grupos -->
            <div class="section">
                <h2 class="section-title">üë• Mis Grupos</h2>
                <div class="section-content">
                    <p style="color: #778DA9; margin-bottom: 15px;">
                        Grupos de trabajo y estudio organizados por tus profesores.
                    </p>
                    <div id="my-groups-container">
                        <div class="loading">Cargando tus grupos...</div>
                    </div>
                </div>
            </div>

            <!-- Secci√≥n Bloques Asignados -->
            <div class="section">
                <h2 class="section-title">üìù Bloques Asignados por Profesores</h2>
                <div class="section-content">
                    <p style="color: #778DA9; margin-bottom: 15px;">
                        Bloques asignados a tus grupos o de forma individual por tus profesores.
                    </p>
                    <div id="assigned-blocks-container">
                        <div class="loading">Cargando bloques asignados...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Script principal del panel -->
    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useContext, createContext } = React;

        // Context para el usuario actual
        const UserContext = createContext();
        const useUser = () => useContext(UserContext);

        // Context para idioma (completo)
        const LanguageContext = createContext();
        const useLanguage = () => useContext(LanguageContext);
        const LanguageProvider = ({ children }) => {
            const t = (key, params = {}) => {
                const translations = {
                    // Traducciones b√°sicas
                    'loading': 'Cargando...',
                    'error': 'Error',
                    'game_setup_title': 'Configuraci√≥n de partida',
                    'game_setup_category': 'Modalidad',
                    'game_setup_training': 'Entrenamiento',
                    'game_setup_competition': 'Competici√≥n',
                    'game_setup_mode': 'Juego',
                    'game_setup_blocks_topics': 'Selecci√≥n de bloques',
                    'game_setup_configure': 'Configurar',
                    'game_setup_not_selected': 'No seleccionado',
                    'game_setup_all_topics': 'Todos los temas',
                    'game_setup_topics_selected': '{count} tema(s) seleccionado(s)',
                    'game_setup_button_create': 'Nueva Partida',
                    'game_setup_button_challenge': 'Enviar Reto',
                    'game_setup_challenge_user': 'Retar a un Usuario',
                    'game_setup_challenge_random': 'Retar a Aleatorio',
                    'game_setup_select_opponent': 'Selecciona un oponente',
                    'game_setup_selected': 'Seleccionado',
                    'challenge_sent': '¬°Reto enviado correctamente!',
                    'challenge_no_users': 'No hay usuarios disponibles para retar.',
                    'add': 'Agregar',
                    'remove': 'Quitar',
                    'generic_cancel': 'Cancelar',
                    'topic_modal_title': 'Configurar Temas',
                    'topic_modal_subtitle': 'Seleccionar temas para "{blockName}"',
                    'topic_modal_deselect_all': 'Deseleccionar Todo',
                    'topic_modal_select_all': 'Seleccionar Todo',
                    'topic_modal_no_topics': 'Este bloque no tiene temas definidos en sus preguntas.',
                    'topic_modal_save': 'Guardar Selecci√≥n',
                    'admin_blocks_by': 'por',
                    'active_games_title': 'Juegos Activos',
                    'block_management_title': 'Gesti√≥n de Bloques',
                    'game_history_title': 'Historial de Partidas',
                    'created_blocks_title': 'Mis Bloques Creados',
                    // Traducciones para modalidades de juego
                    'game_mode_classic': 'Modo Cl√°sico',
                    'game_mode_timetrial': 'Modo Contrarreloj',
                    'game_mode_lives': 'Modo Vidas',
                    'game_mode_levels': 'Por Niveles',
                    'game_mode_streak': 'Racha de Aciertos',
                    'game_mode_exam': 'Examen Simulado',
                    'game_mode_duel': 'Duelo',
                    'game_mode_trivial': 'Trivial',
                    'game_mode_marathon': 'Marat√≥n'
                };
                let text = translations[key] || key;
                Object.keys(params).forEach(param => {
                    text = text.replace(`{${param}}`, params[param]);
                });
                return text;
            };
            
            return React.createElement(LanguageContext.Provider, { value: { t } }, children);
        };

        // Componente TopicSelectionModal
        const TopicSelectionModal = ({ block, existingSelection, onSave, onClose }) => {
            const { t } = useLanguage();
            const [uniqueTopics, setUniqueTopics] = useState([]);
            const [isLoadingTopics, setIsLoadingTopics] = useState(true);
            const [selectedTopics, setSelectedTopics] = useState(new Set());

            // Cargar temas desde la API cuando se monta el componente
            useEffect(() => {
                const loadTopics = async () => {
                    if (!block || !window.apiDataService) return;
                    
                    setIsLoadingTopics(true);
                    try {
                        console.log(`üîç Loading topics for block ${block.id} from topic_answers table`);
                        const topics = await window.apiDataService.fetchBlockTopics(block.id);
                        
                        // Extraer nombres √∫nicos de temas y ordenarlos
                        const topicNames = [...new Set(topics.map(topic => topic.name || topic.topic || topic).filter(Boolean))].sort();
                        setUniqueTopics(topicNames);
                        console.log(`‚úÖ Loaded ${topicNames.length} unique topics for block ${block.id}:`, topicNames);
                        
                        // Establecer selecci√≥n inicial
                        if (existingSelection === 'all') {
                            setSelectedTopics(new Set(topicNames));
                        } else {
                            setSelectedTopics(new Set(existingSelection || []));
                        }
                    } catch (error) {
                        console.error(`‚ùå Error loading topics for block ${block.id}:`, error);
                        setUniqueTopics([]);
                    } finally {
                        setIsLoadingTopics(false);
                    }
                };
                
                loadTopics();
            }, [block, existingSelection]);

            const handleToggleTopic = (topic) => {
                setSelectedTopics(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(topic)) newSet.delete(topic);
                    else newSet.add(topic);
                    return newSet;
                });
            };

            const handleSelectAll = () => {
                if (selectedTopics.size === uniqueTopics.length) {
                    setSelectedTopics(new Set());
                } else {
                    setSelectedTopics(new Set(uniqueTopics));
                }
            };

            const handleSave = () => {
                if (selectedTopics.size === 0) {
                    onSave(block.id, null);
                } else if (selectedTopics.size === uniqueTopics.length) {
                    onSave(block.id, 'all');
                } else {
                    onSave(block.id, Array.from(selectedTopics));
                }
            };
            
            if (!block) return null;

            return React.createElement('div', {
                className: "fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50",
                onClick: onClose
            }, React.createElement('div', {
                className: "bg-slate-800 rounded-xl shadow-2xl w-full max-w-md m-4 border border-slate-600",
                onClick: e => e.stopPropagation()
            }, [
                React.createElement('div', {
                    key: 'header',
                    className: "p-6 border-b border-slate-600"
                }, [
                    React.createElement('h4', {
                        key: 'title',
                        className: "text-xl font-bold text-white"
                    }, t('topic_modal_title')),
                    React.createElement('p', {
                        key: 'subtitle',
                        className: "text-sm text-gray-400"
                    }, t('topic_modal_subtitle', {blockName: block.nombreCorto}))
                ]),
                React.createElement('div', {
                    key: 'content',
                    className: "p-6 max-h-96 overflow-y-auto"
                }, isLoadingTopics ? 
                    React.createElement('div', {
                        className: "text-center text-gray-400 py-8"
                    }, [
                        React.createElement('div', {
                            key: 'spinner',
                            className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"
                        }),
                        React.createElement('p', {
                            key: 'text'
                        }, 'Cargando temas...')
                    ]) :
                    uniqueTopics.length > 0 ? [
                        React.createElement('button', {
                            key: 'select-all',
                            onClick: handleSelectAll,
                            className: "w-full text-sm font-semibold bg-slate-700 hover:bg-slate-600 text-white py-2 rounded-md transition-colors mb-4"
                        }, `${selectedTopics.size === uniqueTopics.length ? t('topic_modal_deselect_all') : t('topic_modal_select_all')} (${uniqueTopics.length})`),
                        React.createElement('div', {
                            key: 'topics',
                            className: "space-y-2"
                        }, uniqueTopics.map(topic =>
                            React.createElement('label', {
                                key: topic,
                                className: "flex items-center p-3 rounded-md hover:bg-slate-700 cursor-pointer transition-colors"
                            }, [
                                React.createElement('input', {
                                    key: 'checkbox',
                                    type: "checkbox",
                                    checked: selectedTopics.has(topic),
                                    onChange: () => handleToggleTopic(topic),
                                    className: "h-4 w-4 rounded border-slate-600 text-blue-600 bg-slate-800 focus:ring-blue-600 focus:ring-2"
                                }),
                                React.createElement('span', {
                                    key: 'label',
                                    className: "ml-3 text-white"
                                }, topic)
                            ])
                        ))
                    ] : React.createElement('p', {
                        className: "text-center text-gray-400 py-8"
                    }, t('topic_modal_no_topics'))),
                React.createElement('div', {
                    key: 'footer',
                    className: "p-4 bg-slate-900 flex justify-end gap-3 rounded-b-xl"
                }, [
                    React.createElement('button', {
                        key: 'cancel',
                        onClick: onClose,
                        className: "py-2 px-4 rounded-lg bg-slate-600 hover:bg-slate-500 text-white font-semibold transition-colors"
                    }, t('generic_cancel')),
                    React.createElement('button', {
                        key: 'save',
                        onClick: handleSave,
                        disabled: isLoadingTopics,
                        className: `py-2 px-4 rounded-lg font-bold transition-colors ${
                            isLoadingTopics 
                                ? 'bg-slate-600 text-gray-400 cursor-not-allowed' 
                                : 'bg-blue-600 hover:bg-blue-700 text-white'
                        }`
                    }, isLoadingTopics ? 'Cargando...' : t('topic_modal_save'))
                ])
            ]));
        };

        // Componente GameSetup completo
        const GameSetup = ({ blocks, onCreateGame, onSendChallenge }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [allUsers, setAllUsers] = useState([]);
            const [allProfiles, setAllProfiles] = useState({});
            const [blockFilter, setBlockFilter] = useState('all'); // 'all', 'class:id', 'group:id'
            const [userClasses, setUserClasses] = useState([]);
            const [userGroups, setUserGroups] = useState([]);
            const [assignedBlocks, setAssignedBlocks] = useState([]);

            const trainingModes = [
                { key: 'game_mode_classic', value: 'Modo Cl√°sico', image: './Imagenes/Clasico.png'},
                { key: 'game_mode_timetrial', value: 'Modo Contrarreloj', image: './Imagenes/Contrarreloj.png'},
                { key: 'game_mode_lives', value: 'Modo Vidas', image: './Imagenes/Vidas.png'},
                { key: 'game_mode_levels', value: 'Por Niveles', image: './Imagenes/Niveles.png'},
                { key: 'game_mode_streak', value: 'Racha de Aciertos', image: './Imagenes/Racha.png'},
                { key: 'game_mode_exam', value: 'Examen Simulado', image: './Imagenes/Examen.png'},
            ];
            const competitionModes = [
                { key: 'game_mode_duel', value: 'Duelo', image: './Imagenes/Duelo.png' },
                { key: 'game_mode_trivial', value: 'Trivial', image: './Imagenes/Trivia.png' },
                { key: 'game_mode_marathon', value: 'Marat√≥n', image: './Imagenes/Maraton.png' },
            ];

            const [category, setCategory] = useState('Entrenamiento');
            const [mode, setMode] = useState(trainingModes[0].value);
            const [configuredBlocks, setConfiguredBlocks] = useState({});
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [blockToConfigure, setBlockToConfigure] = useState(null);
            const [challengedUserId, setChallengedUserId] = useState('');
            const [challengeStatus, setChallengeStatus] = useState('');
            const [duelQuestionCount, setDuelQuestionCount] = useState(20);

            const isCompetitionMode = useMemo(() => category === 'Competici√≥n' && (mode === 'Duelo' || mode === 'Trivial'), [category, mode]);

            useEffect(() => {
                if (category === 'Entrenamiento') setMode(trainingModes[0].value);
                else setMode(competitionModes[0].value);
            }, [category]);
            
            useEffect(() => {
                const fetchUsersAndProfiles = async () => {
                    if (window.apiDataService) {
                        try {
                            const [users, profiles] = await Promise.all([
                                window.apiDataService.fetchAllUsers(),
                                window.apiDataService.fetchAllUserProfiles()
                            ]);
                            setAllUsers(users || []);
                            setAllProfiles(profiles || {});
                        } catch (error) {
                            console.error('Error fetching users:', error);
                        }
                    }
                };
                fetchUsersAndProfiles();
            }, []);

            // Fetch user's classes, groups, and assigned blocks for filters
            useEffect(() => {
                const fetchFilterData = async () => {
                    const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                    if (!session.token) return;

                    const API_URL = window.location.hostname.includes('onrender.com')
                        ? 'https://playtest-backend.onrender.com/api'
                        : 'http://localhost:3001/api';

                    try {
                        // Fetch user's classes
                        const classesResponse = await fetch(`${API_URL}/students/my-classes`, {
                            headers: { 'Authorization': `Bearer ${session.token}` }
                        });
                        if (classesResponse.ok) {
                            const classes = await classesResponse.json();
                            setUserClasses(classes || []);
                        }

                        // Fetch user's groups
                        const groupsResponse = await fetch(`${API_URL}/groups/my-groups`, {
                            headers: { 'Authorization': `Bearer ${session.token}` }
                        });
                        if (groupsResponse.ok) {
                            const groups = await groupsResponse.json();
                            setUserGroups(groups || []);
                        }

                        // Fetch assigned blocks
                        const assignedResponse = await fetch(`${API_URL}/groups/my-assigned-blocks`, {
                            headers: { 'Authorization': `Bearer ${session.token}` }
                        });
                        if (assignedResponse.ok) {
                            const assigned = await assignedResponse.json();
                            setAssignedBlocks(assigned || []);
                        }
                    } catch (error) {
                        console.error('Error fetching filter data:', error);
                    }
                };
                fetchFilterData();
            }, []);
            
            // Filter blocks based on selected filter
            const filteredBlocks = useMemo(() => {
                if (blockFilter === 'all') {
                    return blocks;
                }

                if (blockFilter.startsWith('class:')) {
                    const classId = parseInt(blockFilter.split(':')[1]);
                    // Get blocks assigned to groups that belong to this class
                    // Note: We need to check if groups belong to a class, but the API doesn't provide this
                    // For now, we'll show blocks from all groups as "class" is more of a concept
                    const classAssignedBlockIds = assignedBlocks
                        .filter(ab => ab.assignment_type === 'GROUP')
                        .map(ab => ab.id);
                    return blocks.filter(b => classAssignedBlockIds.includes(b.id));
                }

                if (blockFilter.startsWith('group:')) {
                    const groupId = parseInt(blockFilter.split(':')[1]);
                    // Get blocks assigned to this specific group
                    const groupAssignedBlockIds = assignedBlocks
                        .filter(ab => {
                            // Check if assignment is to this group (for GROUP assignments)
                            // or if user is in this group (could be INDIVIDUAL but user is in group)
                            return ab.assignment_type === 'GROUP' && ab.group_name &&
                                   userGroups.some(g => g.id === groupId && g.name === ab.group_name);
                        })
                        .map(ab => ab.id);
                    return blocks.filter(b => groupAssignedBlockIds.includes(b.id));
                }

                if (blockFilter === 'individual') {
                    // Get blocks assigned individually to this user
                    const individualBlockIds = assignedBlocks
                        .filter(ab => ab.assignment_type === 'INDIVIDUAL')
                        .map(ab => ab.id);
                    return blocks.filter(b => individualBlockIds.includes(b.id));
                }

                return blocks;
            }, [blocks, blockFilter, assignedBlocks, userGroups]);

            const challengeableUsers = useMemo(() => {
                const selectedBlockIds = Object.keys(configuredBlocks).map(id => parseInt(id));
                if (!isCompetitionMode || selectedBlockIds.length === 0) return [];

                return allUsers.filter(user => {
                    if (user.isAdmin || user.id === currentUser.id) return false;
                    const profile = allProfiles[user.id];
                    if (!profile || !profile.loadedBlocks) return false;

                    const userLoadedBlocks = profile.loadedBlocks.map(id => parseInt(id));
                    return selectedBlockIds.every(blockId => userLoadedBlocks.includes(blockId));
                });
            }, [allUsers, allProfiles, configuredBlocks, currentUser?.id, isCompetitionMode]);

            const handleToggleBlockForCompetition = (blockId) => {
                setConfiguredBlocks(prev => {
                    const newConfig = { ...prev };
                    if (newConfig[blockId]) {
                        delete newConfig[blockId];
                    } else {
                        newConfig[blockId] = { topics: 'all' };
                    }
                    return newConfig;
                });
            };

            const handleOpenModal = (block) => { setBlockToConfigure(block); setIsModalOpen(true); };
            const handleCloseModal = () => { setBlockToConfigure(null); setIsModalOpen(false); };
            
            const handleSaveTopicSelection = (blockId, topics) => {
                setConfiguredBlocks(prev => {
                    const newConfig = { ...prev };
                    if (topics) newConfig[blockId] = { topics };
                    else delete newConfig[blockId];
                    return newConfig;
                });
                handleCloseModal();
            };

            const handleGameAction = () => {
                if (Object.keys(configuredBlocks).length === 0) return;

                // Add duelQuestionCount to config if mode is Duelo
                const enhancedConfig = mode === 'Duelo'
                    ? { mode, config: configuredBlocks, duelQuestionCount }
                    : { mode, config: configuredBlocks };

                // DEBUG: Log game configuration before sending
                console.log('üéÆ GAME DEBUG - handleGameAction:', {
                    mode: mode,
                    configuredBlocks: configuredBlocks,
                    duelQuestionCount: duelQuestionCount,
                    configuredBlocksKeys: Object.keys(configuredBlocks),
                    configuredBlocksLength: Object.keys(configuredBlocks).length,
                    gameConfig: enhancedConfig
                });

                if (isCompetitionMode) {
                    console.log('üéØ COMPETITION DEBUG - Challenge details:', {
                        isCompetitionMode: isCompetitionMode,
                        challengedUserId: challengedUserId,
                        challengeableUsersCount: challengeableUsers.length,
                        challengeableUsers: challengeableUsers,
                        duelQuestionCount: duelQuestionCount
                    });
                    const challengedUser = challengeableUsers.find(u => u.id.toString() === challengedUserId.toString());
                    console.log('üë§ Found challengedUser:', challengedUser);
                    if (!challengedUser) {
                        console.error('‚ùå No challenged user found!');
                        return;
                    }
                    console.log('üìû About to call onSendChallenge...');
                    onSendChallenge(challengedUser, enhancedConfig);
                    setChallengeStatus(t('challenge_sent'));
                    setTimeout(() => setChallengeStatus(''), 3000);
                } else {
                    onCreateGame(enhancedConfig);
                }

                setConfiguredBlocks({});
                setChallengedUserId('');
            };

            const handleRandomChallenge = () => {
                if (challengeableUsers.length === 0) return;
                const randomUser = challengeableUsers[Math.floor(Math.random() * challengeableUsers.length)];

                // Add duelQuestionCount to config if mode is Duelo
                const enhancedConfig = mode === 'Duelo'
                    ? { mode, config: configuredBlocks, duelQuestionCount }
                    : { mode, config: configuredBlocks };

                onSendChallenge(randomUser, enhancedConfig);
                setChallengeStatus(t('challenge_sent'));
                setTimeout(() => setChallengeStatus(''), 3000);
                setConfiguredBlocks({});
                setChallengedUserId('');
            };
            
            const getBlockSelectionText = (blockId) => {
                const config = configuredBlocks[blockId];
                if (!config) return React.createElement('span', { className: "text-gray-400" }, t('game_setup_not_selected'));
                if (config.topics === 'all') return React.createElement('span', { className: "text-green-400" }, t('game_setup_all_topics'));
                return React.createElement('span', { className: "text-blue-400" }, t('game_setup_topics_selected', {count: config.topics.length}));
            };
            
            const buttonDisabled = Object.keys(configuredBlocks).length === 0 || (isCompetitionMode && !challengedUserId);
            const buttonText = isCompetitionMode ? t('game_setup_button_challenge') : t('game_setup_button_create');

            return React.createElement('div', { 
                className: "bg-slate-800 p-6 rounded-xl shadow-lg" 
            }, [
                isModalOpen && blockToConfigure && React.createElement(TopicSelectionModal, {
                    key: 'modal',
                    block: blockToConfigure,
                    existingSelection: configuredBlocks[blockToConfigure.id]?.topics,
                    onSave: handleSaveTopicSelection,
                    onClose: handleCloseModal
                }),
                
                // Content
                React.createElement('div', {
                    key: 'content',
                    className: "space-y-4"
                }, [
                    // Category selector
                    React.createElement('div', { key: 'category' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-1"
                        }, t('game_setup_category')),
                        React.createElement('select', {
                            key: 'select',
                            value: category,
                            onChange: (e) => setCategory(e.target.value),
                            className: "w-full bg-slate-900 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none"
                        }, [
                            React.createElement('option', { key: 'training', value: "Entrenamiento" }, t('game_setup_training')),
                            React.createElement('option', { key: 'competition', value: "Competici√≥n" }, t('game_setup_competition'))
                        ])
                    ]),

                    // Mode selector
                    React.createElement('div', { key: 'mode' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-2"
                        }, t('game_setup_mode')),
                        React.createElement('div', {
                            key: 'grid',
                            className: "grid grid-cols-2 sm:grid-cols-3 gap-3"
                        }, (category === 'Entrenamiento' ? trainingModes : competitionModes).map(m =>
                            React.createElement('button', {
                                key: m.key,
                                type: "button",
                                onClick: () => setMode(m.value),
                                className: `p-3 text-center rounded-lg border-2 transition-all duration-200 ${mode === m.value ? 'bg-blue-600/20 border-blue-600' : 'bg-slate-900 border-slate-600 hover:border-gray-400'}`
                            }, [
                                React.createElement('div', {
                                    key: 'image-container',
                                    className: "w-24 h-24 mx-auto mb-2 rounded-full bg-slate-700 flex items-center justify-center ring-1 ring-slate-600"
                                }, React.createElement('img', {
                                    key: 'image',
                                    src: m.image,
                                    alt: t(m.key),
                                    className: "h-16 w-16 object-contain"
                                })),
                                React.createElement('span', {
                                    key: 'text',
                                    className: "text-xs font-semibold text-white"
                                }, t(m.key))
                            ])
                        ))
                    ]),

                    // Competition mode options
                    isCompetitionMode && React.createElement('div', {
                        key: 'competition',
                        className: "p-3 bg-slate-900 rounded-lg space-y-2"
                    }, [
                        React.createElement('div', { key: 'opponent-select' }, [
                            React.createElement('label', {
                                key: 'label',
                                className: "block text-sm font-medium text-gray-400 mb-1"
                            }, t('game_setup_challenge_user')),
                            React.createElement('select', {
                                key: 'select',
                                value: challengedUserId,
                                onChange: (e) => setChallengedUserId(e.target.value),
                                className: "w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none",
                                disabled: Object.keys(configuredBlocks).length === 0
                            }, [
                                React.createElement('option', { key: 'default', value: "" }, t('game_setup_select_opponent')),
                                ...(challengeableUsers.length > 0 ?
                                    challengeableUsers.map(user =>
                                        React.createElement('option', { key: user.id, value: user.id }, user.nickname)
                                    ) :
                                    [React.createElement('option', { key: 'no-users', disabled: true }, t('challenge_no_users'))]
                                )
                            ])
                        ]),
                        // Duel question count selector (only for Duelo mode)
                        mode === 'Duelo' && React.createElement('div', { key: 'question-count' }, [
                            React.createElement('label', {
                                key: 'label',
                                className: "block text-sm font-medium text-gray-400 mb-1"
                            }, 'N√∫mero de preguntas'),
                            React.createElement('select', {
                                key: 'select',
                                value: duelQuestionCount,
                                onChange: (e) => setDuelQuestionCount(parseInt(e.target.value)),
                                className: "w-full bg-slate-800 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none"
                            }, [
                                React.createElement('option', { key: '20', value: 20 }, '20 preguntas'),
                                React.createElement('option', { key: '30', value: 30 }, '30 preguntas'),
                                React.createElement('option', { key: '40', value: 40 }, '40 preguntas'),
                                React.createElement('option', { key: '50', value: 50 }, '50 preguntas')
                            ]),
                            React.createElement('p', {
                                key: 'helper',
                                className: "text-xs text-gray-400 mt-1"
                            }, `Cada jugador responder√° ${duelQuestionCount / 2} preguntas (${duelQuestionCount / 2} rondas)`)
                        ]),
                        React.createElement('div', {
                            key: 'divider',
                            className: "flex items-center gap-2"
                        }, [
                            React.createElement('div', { key: 'line1', className: "flex-grow border-t border-slate-600" }),
                            React.createElement('span', { key: 'or', className: "text-xs text-gray-400" }, 'O'),
                            React.createElement('div', { key: 'line2', className: "flex-grow border-t border-slate-600" })
                        ]),
                        React.createElement('button', {
                            key: 'random',
                            onClick: handleRandomChallenge,
                            disabled: challengeableUsers.length === 0,
                            className: "w-full bg-slate-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-500 transition-colors disabled:bg-slate-700 disabled:cursor-not-allowed"
                        }, t('game_setup_challenge_random'))
                    ]),

                    // Block filter selector
                    React.createElement('div', { key: 'block-filter' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-1"
                        }, 'Filtrar bloques'),
                        React.createElement('select', {
                            key: 'select',
                            value: blockFilter,
                            onChange: (e) => setBlockFilter(e.target.value),
                            className: "w-full bg-slate-900 border border-slate-600 rounded-lg px-3 py-2 text-white focus:ring-2 focus:ring-blue-600 focus:outline-none"
                        }, [
                            React.createElement('option', { key: 'all', value: 'all' }, 'üìö Todos los bloques cargados'),
                            React.createElement('option', { key: 'individual', value: 'individual' }, 'üë§ Bloques asignados individualmente'),
                            userClasses.length > 0 && React.createElement('optgroup', { key: 'classes', label: 'üéì Por clase' },
                                userClasses.map(cls =>
                                    React.createElement('option', { key: `class-${cls.id}`, value: `class:${cls.id}` }, cls.name)
                                )
                            ),
                            userGroups.length > 0 && React.createElement('optgroup', { key: 'groups', label: 'üë• Por grupo' },
                                userGroups.map(grp =>
                                    React.createElement('option', { key: `group-${grp.id}`, value: `group:${grp.id}` }, grp.name)
                                )
                            )
                        ])
                    ]),

                    // Block selection
                    React.createElement('div', { key: 'blocks' }, [
                        React.createElement('label', {
                            key: 'label',
                            className: "block text-sm font-medium text-gray-400 mb-2"
                        }, t('game_setup_blocks_topics')),
                        filteredBlocks.length === 0 ? React.createElement('div', {
                            key: 'empty',
                            className: "text-center py-8 text-gray-400"
                        }, [
                            React.createElement('div', { key: 'icon', className: "text-4xl mb-2" }, 'üì≠'),
                            React.createElement('p', { key: 'text' }, 'No hay bloques para este filtro')
                        ]) : React.createElement('div', {
                            key: 'list',
                            className: "max-h-40 overflow-y-auto space-y-2 p-1"
                        }, filteredBlocks.map(block =>
                            React.createElement('div', {
                                key: block.id,
                                className: "flex items-center justify-between p-2 rounded-md hover:bg-slate-700 transition-colors"
                            }, [
                                React.createElement('div', { key: 'info', className: "overflow-hidden" }, [
                                    React.createElement('p', {
                                        key: 'name',
                                        className: "font-semibold text-white truncate"
                                    }, block.nombreCorto),
                                    React.createElement('p', {
                                        key: 'creator',
                                        className: "text-xs text-gray-400 truncate"
                                    }, `${t('admin_blocks_by')} ${block.creatorNickname}`),
                                    React.createElement('p', {
                                        key: 'status',
                                        className: "text-xs mt-1"
                                    }, category === 'Competici√≥n' ? 
                                        (configuredBlocks[block.id] ? 
                                            React.createElement('span', { className: "text-green-400" }, t('game_setup_selected')) : 
                                            React.createElement('span', { className: "text-gray-400" }, t('game_setup_not_selected'))
                                        ) : getBlockSelectionText(block.id)
                                    )
                                ]),
                                category === 'Competici√≥n' ? 
                                    React.createElement('button', {
                                        key: 'toggle',
                                        onClick: () => handleToggleBlockForCompetition(block.id),
                                        className: `text-sm font-semibold py-1 px-3 rounded-md transition-colors ${configuredBlocks[block.id] ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'}`
                                    }, configuredBlocks[block.id] ? t('remove') : t('add')) :
                                    React.createElement('button', {
                                        key: 'config',
                                        onClick: () => handleOpenModal(block),
                                        className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-3 rounded-md transition-colors"
                                    }, t('game_setup_configure'))
                            ])
                        ))
                    ]),

                    // Challenge status
                    challengeStatus && React.createElement('p', {
                        key: 'status',
                        className: "text-center text-sm text-green-400 animate-pulse"
                    }, challengeStatus),

                    // Action button
                    React.createElement('button', {
                        key: 'action',
                        onClick: handleGameAction,
                        disabled: buttonDisabled,
                        className: "w-full mt-2 bg-blue-600 text-white font-bold py-2.5 px-4 rounded-lg hover:bg-blue-700 transition-colors disabled:bg-slate-600 disabled:cursor-not-allowed"
                    }, buttonText)
                ])
            ]);
        };

        // Componente ActiveGames completo (con retos pendientes)
        const ActiveGames = ({ games, gameConfigurations, challenges, blocks, onDeleteGame, onNavigateToGame, onAcceptChallenge, onDeclineChallenge, handleDeleteConfiguration, onRepeatConfiguration, setCurrentView }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);

            const getGameConfigDetails = (config, metadata) => {
                if (!config || Object.keys(config).length === 0) return 'Sin configuraci√≥n de bloques';
                
                if (metadata && metadata.blocks) {
                    const blockSummary = metadata.blocks.map(block => {
                        const topicInfo = block.isAllTopics 
                            ? 'todos los temas'
                            : `${block.selectedTopics.length} temas`;
                        return `${block.blockName} (${topicInfo}, ${block.questionCount} preguntas)`;
                    }).join(' | ');
                    
                    return `${metadata.summary.blockCount} bloques, ${metadata.summary.questionCount} preguntas: ${blockSummary}`;
                }
                
                return Object.entries(config).map(([blockId, blockConfig]) => {
                    const block = blocks.find(b => b.id === parseInt(blockId) || b.id === blockId);
                    const blockName = block ? block.nombreCorto : 'Bloque Desconocido';
                    const topicInfo = blockConfig.topics === 'all'
                        ? 'todos los temas'
                        : `${Array.isArray(blockConfig.topics) ? blockConfig.topics.length : 0} temas`;
                    return `${blockName} (${topicInfo})`;
                }).join(' | ');
            };

            // Helper to get turn and round information for multiplayer games
            const getTurnInfo = (game) => {
                console.log('üéØ getTurnInfo called for game:', game.id, {
                    mode: game.mode,
                    turnState: game.turnState,
                    turn: game.turn,
                    round: game.round,
                    players: game.players,
                    playersLength: game.players?.length,
                    gameState: game.gameState
                });

                if (game.mode !== 'Duelo' && game.mode !== 'Trivial') {
                    console.log('‚è≠Ô∏è Not a multiplayer game, returning null');
                    return null;
                }

                if (!game.players || game.players.length < 2) {
                    console.log('‚ùå Missing players data');
                    return null;
                }

                let currentPlayerIndex = -1;
                let roundInfo = null;

                // Handle Duel mode
                if (game.mode === 'Duelo') {
                    if (!game.turnState) {
                        console.log('‚ùå Missing turnState for Duel game');
                        return null;
                    }

                    const turnState = game.turnState;
                    if (turnState.startsWith('p1')) {
                        currentPlayerIndex = 0;
                    } else if (turnState.startsWith('p2')) {
                        currentPlayerIndex = 1;
                    }

                    // Get round info from game state
                    if (game.round !== undefined) {
                        roundInfo = `Ronda ${game.round + 1}/10`;
                    }
                }

                // Handle Trivial mode
                if (game.mode === 'Trivial') {
                    if (game.turn !== undefined) {
                        currentPlayerIndex = game.turn;
                    } else {
                        console.log('‚ùå Missing turn for Trivial game');
                        return null;
                    }

                    // Get round info for Trivial
                    if (game.round !== undefined) {
                        roundInfo = `Ronda ${game.round}`;
                    }
                }

                console.log('üë§ Current player index:', currentPlayerIndex);

                if (currentPlayerIndex === -1 || !game.players[currentPlayerIndex]) return null;

                const currentPlayer = game.players[currentPlayerIndex];
                const isMyTurn = currentPlayer.userId === currentUser.id;

                console.log('‚úÖ Turn info:', {
                    playerNickname: currentPlayer.nickname,
                    isMyTurn,
                    roundInfo,
                    currentUserId: currentUser.id,
                    currentPlayerUserId: currentPlayer.userId
                });

                return {
                    playerNickname: currentPlayer.nickname,
                    isMyTurn,
                    roundInfo
                };
            };

            const handleDeleteClick = (gameId) => {
                setConfirmingDeleteId(gameId);
            };
            
            const handleConfirmDelete = () => {
                if (confirmingDeleteId) {
                    onDeleteGame(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };

            // Filtrar juegos activos: solo Duelo y Trivial que no han finalizado
            const activeCompetitionGames = games.filter(g =>
                (g.status === 'active' || g.status === 'waiting') &&
                (g.mode === 'Duelo' || g.mode === 'Trivial')
            );

            // Resto de partidas: juegos completados o de otros modos
            const availableGames = games.filter(g =>
                g.status === 'completed' ||
                ((g.status === 'active' || g.status === 'waiting') && g.mode !== 'Duelo' && g.mode !== 'Trivial')
            );

            // Separate incoming challenges (where current user is challenged) from outgoing (where current user is challenger)
            // Status can be 'waiting' (pending challenge) or 'pending' (legacy)
            const incomingChallenges = challenges.filter(c =>
                (c.status === 'waiting' || c.status === 'pending') && c.direction === 'incoming'
            );
            const outgoingChallenges = challenges.filter(c =>
                (c.status === 'waiting' || c.status === 'pending') && c.direction === 'outgoing'
            );

            // Enhanced function to accept challenge and start game directly
            const handleAcceptAndStartGame = async (challengeId, challenge) => {
                try {
                    if (window.apiDataService) {
                        console.log('üéÆ Accepting challenge and starting game:', { challengeId, challenge });

                        // Accept the challenge (this changes status from 'pending' to 'active')
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);

                        // Store game info in localStorage for navigation
                        localStorage.setItem('current_game_id', challengeId);
                        localStorage.setItem('current_game_mode', challenge.mode || 'Partida');

                        // Navigate directly to the game with the challenge's game ID
                        console.log('üöÄ Redirecting to game:', challengeId);
                        if (onNavigateToGame) {
                            onNavigateToGame({ id: challengeId, mode: challenge.mode, ...challenge });
                        } else {
                            // Direct navigation fallback
                            window.location.href = `active-game.html?gameId=${challengeId}`;
                        }
                    }
                } catch (err) {
                    console.error('‚ùå Error accepting challenge and starting game:', err);
                }
            };

            // Enhanced function to decline challenge with reason
            const handleDeclineWithReason = async (challengeId, challengerNickname) => {
                const reason = prompt(
                    `¬øPor qu√© declinas el reto de ${challengerNickname}?\n\n(Opcional: Puedes dejar este campo vac√≠o o escribir una raz√≥n que ser√° enviada al retador)`
                );

                // Allow cancellation
                if (reason === null) return;

                try {
                    if (window.apiDataService) {
                        console.log('‚ùå Declining challenge with reason:', { challengeId, reason });

                        // Send decline with reason to backend
                        await window.apiDataService.declineChallengeWithReason(currentUser.id, challengeId, reason || '');
                    }
                } catch (err) {
                    console.error('‚ùå Error declining challenge with reason:', err);
                }
            };


            // Enhanced helper for challenge configuration with more detail
            const getChallengeConfigDetails = (challenge) => {
                if (!challenge.config) return 'Sin configuraci√≥n disponible';
                
                const config = challenge.config;
                const metadata = challenge.configurationMetadata;
                const mode = challenge.mode || 'Modo no especificado';
                
                let details = [];
                details.push(`üéÆ Modo: ${mode}`);
                
                const blockIds = Object.keys(config);
                details.push(`üìö ${blockIds.length} bloque${blockIds.length !== 1 ? 's' : ''}`);
                
                if (metadata && metadata.blockDetails) {
                    const blockInfo = metadata.blockDetails.map(block => {
                        const blockConfig = config[block.id];
                        if (blockConfig && blockConfig.topics) {
                            return `‚Ä¢ ${block.name} (${blockConfig.topics.length} tema${blockConfig.topics.length !== 1 ? 's' : ''})`;
                        }
                        return `‚Ä¢ ${block.name}`;
                    });
                    details.push(...blockInfo);
                }
                
                return details;
            };

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col h-full"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminaci√≥n'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¬øEst√°s seguro de que quieres eliminar este juego?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                (activeCompetitionGames.length > 0 || availableGames.length > 0) && React.createElement('div', {
                    key: 'header',
                    className: "flex justify-end mb-4 flex-shrink-0"
                }, React.createElement('a', {
                    key: 'view-all',
                    href: "/all-games.html",
                    className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-3 rounded-md transition-colors"
                }, `Ver todos (${activeCompetitionGames.length + availableGames.length})`)),
                
                React.createElement('div', {
                    key: 'content',
                    className: "space-y-4 overflow-y-auto pr-2 flex-grow"
                }, [
                    // Incoming challenges (user is being challenged)
                    incomingChallenges.length > 0 && React.createElement('div', { key: 'incoming-challenges' }, [
                        React.createElement('h4', {
                            key: 'incoming-title',
                            className: "font-semibold text-amber-400 mb-2"
                        }, 'Retos Recibidos'),
                        React.createElement('ul', {
                            key: 'incoming-list',
                            className: "space-y-3 mb-4"
                        }, incomingChallenges.map(challenge => {
                            const challenger = challenge.challenger;
                            const configDetails = getChallengeConfigDetails(challenge);
                            
                            return React.createElement('li', {
                                key: challenge.id,
                                className: "p-4 rounded-md bg-amber-500/10 border border-amber-500/30"
                            }, [
                                React.createElement('div', { key: 'challenge-header', className: "flex items-start gap-3 mb-3" }, [
                                    React.createElement('div', {
                                        key: 'sword-icon',
                                        className: "h-8 w-8 text-amber-400 flex-shrink-0 flex items-center justify-center"
                                    }, '‚öîÔ∏è'),
                                    React.createElement('div', { key: 'challenge-main', className: "flex-grow" }, [
                                        React.createElement('p', {
                                            key: 'challenger',
                                            className: "font-bold text-white text-lg"
                                        }, `Reto de ${challenger?.nickname}`),
                                        React.createElement('p', {
                                            key: 'mode',
                                            className: "text-amber-300 font-semibold"
                                        }, challenge.mode || 'Modo no especificado')
                                    ])
                                ]),
                                
                                React.createElement('div', { key: 'challenge-config', className: "mb-4 pl-11" }, [
                                    React.createElement('div', {
                                        key: 'config-title',
                                        className: "text-sm font-semibold text-gray-300 mb-2"
                                    }, 'üìã Configuraci√≥n de la partida:'),
                                    React.createElement('div', {
                                        key: 'config-details',
                                        className: "text-sm text-gray-400 space-y-1"
                                    }, configDetails.map((detail, index) => 
                                        React.createElement('div', { key: index }, detail)
                                    ))
                                ]),
                                
                                React.createElement('div', { key: 'challenge-actions', className: "flex justify-end gap-3" }, [
                                    React.createElement('button', {
                                        key: 'decline',
                                        onClick: () => handleDeclineWithReason(challenge.id, challenger?.nickname),
                                        className: "py-2 px-4 text-sm rounded-lg bg-red-600 hover:bg-red-700 text-white font-bold transition-colors"
                                    }, '‚ùå Declinar'),
                                    React.createElement('button', {
                                        key: 'accept',
                                        onClick: () => handleAcceptAndStartGame(challenge.id, challenge),
                                        className: "py-2 px-4 text-sm rounded-lg bg-green-600 hover:bg-green-700 text-white font-bold transition-colors"
                                    }, '‚úÖ Aceptar y Jugar')
                                ])
                            ]);
                        }))
                    ]),

                    // Outgoing challenges (user has challenged others)
                    outgoingChallenges.length > 0 && React.createElement('div', { key: 'outgoing-challenges' }, [
                        React.createElement('h4', {
                            key: 'outgoing-title',
                            className: "font-semibold text-blue-400 mb-2"
                        }, 'Retos Enviados'),
                        React.createElement('ul', {
                            key: 'outgoing-list',
                            className: "space-y-3 mb-4"
                        }, outgoingChallenges.map(challenge => {
                            const challenged = challenge.challenged;
                            return React.createElement('li', {
                                key: challenge.id,
                                className: "p-3 rounded-md bg-blue-500/10 border border-blue-500/30"
                            }, [
                                React.createElement('div', { key: 'challenge-info', className: "flex items-center gap-3" }, [
                                    React.createElement('div', {
                                        key: 'clock-icon',
                                        className: "h-6 w-6 text-blue-400 flex-shrink-0"
                                    }, '‚è≥'),
                                    React.createElement('div', { key: 'challenge-details', className: "flex-grow overflow-hidden" }, [
                                        React.createElement('p', {
                                            key: 'challenged',
                                            className: "font-semibold text-white truncate"
                                        }, `Retaste a ${challenged?.nickname} en ${challenge.mode}`),
                                        React.createElement('p', {
                                            key: 'status',
                                            className: "text-xs text-blue-400"
                                        }, 'Esperando respuesta...'),
                                        React.createElement('p', {
                                            key: 'config',
                                            className: "text-xs text-gray-400 truncate",
                                            title: getGameConfigDetails(challenge.config, challenge.configurationMetadata)
                                        }, getGameConfigDetails(challenge.config, challenge.configurationMetadata))
                                    ])
                                ])
                            ]);
                        }))
                    ]),

                    // Secci√≥n Juegos Activos (Duelo y Trivial)
                    activeCompetitionGames.length > 0 && React.createElement('div', { key: 'competition-games-section' }, [
                        React.createElement('h4', {
                            key: 'competition-title',
                            className: "font-semibold text-green-400 mb-2"
                        }, 'Juegos Activos'),
                        React.createElement('div', {
                            key: 'competition-container',
                            className: "overflow-y-auto mb-4",
                            style: { maxHeight: '400px' }
                        }, React.createElement('ul', {
                            key: 'competition-list',
                            className: "space-y-3"
                        }, activeCompetitionGames.map(game => React.createElement('li', {
                            key: game.id,
                            className: "p-3 rounded-md bg-green-900/20 border border-green-500/30"
                        }, [
                            React.createElement('div', { key: 'game-header', className: "flex items-center justify-between mb-2" }, [
                                React.createElement('div', { key: 'game-info', className: "flex items-center gap-2" }, [
                                    React.createElement('div', {
                                        key: 'game-icon',
                                        className: "h-6 w-6 text-green-400 flex-shrink-0"
                                    }, 'üéÆ'),
                                    React.createElement('span', {
                                        key: 'game-mode',
                                        className: "font-semibold text-white"
                                    }, game.mode || 'Modo Cl√°sico'),
                                    React.createElement('span', {
                                        key: 'game-status',
                                        className: "text-xs px-2 py-0.5 rounded text-white bg-green-600"
                                    }, 'Activa')
                                ]),
                                React.createElement('button', {
                                    key: 'delete-game',
                                    onClick: () => handleDeleteClick(game.id),
                                    className: "text-red-400 hover:text-red-300 text-sm",
                                    title: "Eliminar juego"
                                }, 'üóëÔ∏è')
                            ]),
                            React.createElement('div', { key: 'game-config', className: "mb-3" }, [
                                React.createElement('p', {
                                    key: 'config-details',
                                    className: "text-xs text-gray-300"
                                }, getGameConfigDetails(game.config, game.configurationMetadata)),
                                (() => {
                                    const turnInfo = getTurnInfo(game);
                                    if (!turnInfo) return null;
                                    const turnText = turnInfo.isMyTurn ? 'üéØ Tu turno' : `‚è≥ Turno de ${turnInfo.playerNickname}`;
                                    const fullText = turnInfo.roundInfo ? `${turnText} ‚Ä¢ ${turnInfo.roundInfo}` : turnText;
                                    return React.createElement('p', {
                                        key: 'turn-info',
                                        className: `text-xs font-semibold mt-1 ${turnInfo.isMyTurn ? 'text-green-400' : 'text-amber-400'}`
                                    }, fullText);
                                })()
                            ]),
                            React.createElement('button', {
                                key: 'continue-game',
                                onClick: () => onNavigateToGame(game),
                                className: "w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm"
                            }, '‚ñ∂Ô∏è Continuar Partida')
                        ]))))
                    ]),

                    // Secci√≥n Partidas Disponibles (resto de configuraciones)
                    availableGames.length > 0 && React.createElement('div', { key: 'available-games-section' }, [
                        React.createElement('h4', {
                            key: 'available-title',
                            className: "font-semibold text-blue-400 mb-2"
                        }, 'Partidas Disponibles'),
                        React.createElement('div', {
                            key: 'available-container',
                            className: "overflow-y-auto mb-4",
                            style: { maxHeight: '400px' }
                        }, React.createElement('ul', {
                            key: 'available-list',
                            className: "space-y-3"
                        }, availableGames.map(game => {
                            const isCompleted = game.status === 'completed';
                            return React.createElement('li', {
                                key: game.id,
                                className: "p-3 rounded-md bg-blue-900/20 border border-blue-500/30"
                            }, [
                                React.createElement('div', { key: 'game-header', className: "flex items-center justify-between mb-2" }, [
                                    React.createElement('div', { key: 'game-info', className: "flex items-center gap-2" }, [
                                        React.createElement('div', {
                                            key: 'game-icon',
                                            className: "h-6 w-6 text-blue-400 flex-shrink-0"
                                        }, 'üéÆ'),
                                        React.createElement('span', {
                                            key: 'game-mode',
                                            className: "font-semibold text-white"
                                        }, game.mode || 'Modo Cl√°sico'),
                                        React.createElement('span', {
                                            key: 'game-status',
                                            className: `text-xs px-2 py-0.5 rounded text-white ${isCompleted ? 'bg-gray-600' : 'bg-blue-600'}`
                                        }, isCompleted ? 'Completada' : 'Activa')
                                    ]),
                                    React.createElement('button', {
                                        key: 'delete-game',
                                        onClick: () => handleDeleteClick(game.id),
                                        className: "text-red-400 hover:text-red-300 text-sm",
                                        title: "Eliminar juego"
                                    }, 'üóëÔ∏è')
                                ]),
                                React.createElement('div', { key: 'game-config', className: "mb-3" }, [
                                    React.createElement('p', {
                                        key: 'config-details',
                                        className: "text-xs text-gray-300"
                                    }, getGameConfigDetails(game.config, game.configurationMetadata)),
                                    (() => {
                                        const turnInfo = getTurnInfo(game);
                                        if (!turnInfo) return null;
                                        const turnText = turnInfo.isMyTurn ? 'üéØ Tu turno' : `‚è≥ Turno de ${turnInfo.playerNickname}`;
                                        const fullText = turnInfo.roundInfo ? `${turnText} ‚Ä¢ ${turnInfo.roundInfo}` : turnText;
                                        return React.createElement('p', {
                                            key: 'turn-info',
                                            className: `text-xs font-semibold mt-1 ${turnInfo.isMyTurn ? 'text-green-400' : 'text-amber-400'}`
                                        }, fullText);
                                    })()
                                ]),
                                React.createElement('button', {
                                    key: 'continue-game',
                                    onClick: () => onNavigateToGame(game),
                                    className: "w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm"
                                }, isCompleted ? 'üîÑ Jugar de Nuevo' : '‚ñ∂Ô∏è Continuar Partida')
                            ]);
                        })))
                    ]),

                    (activeCompetitionGames.length === 0 && availableGames.length === 0) && React.createElement('div', {
                        key: 'no-games',
                        className: "text-center py-6 flex-grow flex items-center justify-center"
                    }, React.createElement('div', { key: 'no-games-content' }, [
                        React.createElement('p', { key: 'no-games-text', className: "text-gray-400" }, 'No hay juegos disponibles'),
                        React.createElement('p', { key: 'no-games-hint', className: "text-sm text-gray-500 mt-1" }, 'Crea una nueva partida para empezar')
                    ]))
                ])
            ]);
        };

        // Componente UserBlockManagement completo (con progreso y estad√≠sticas)
        const UserBlockManagement = ({ blocks, onViewBlock, onDeleteBlock, onOpenAddBlockModal, onOpenStatsModal, setCurrentView }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);
            const [expandedBlockId, setExpandedBlockId] = useState(null);

            const handleDeleteClick = (blockId) => {
                setConfirmingDeleteId(blockId);
            };

            const handleConfirmDelete = () => {
                if (confirmingDeleteId) {
                    onDeleteBlock(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };
            
            const getProgressBarColor = (percentage) => {
                if (percentage < 40) return 'bg-red-600';
                if (percentage < 70) return 'bg-amber-500';
                return 'bg-green-600';
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminaci√≥n'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¬øEst√°s seguro de que quieres eliminar este bloque?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                hasRole(currentUser, 'creador') && React.createElement('div', {
                    key: 'actions',
                    className: "flex justify-end mb-4"
                }, React.createElement('button', {
                    key: 'create',
                    onClick: () => window.location.href = './add-question.html',
                    className: "text-xs font-semibold bg-blue-600 hover:bg-blue-700 text-white py-2 px-3 rounded-md transition-colors"
                }, 'Crear Nuevo Bloque')),

                blocks.length > 0 ? React.createElement('div', {
                    key: 'blocks-list',
                    className: "space-y-3 overflow-y-auto max-h-96 pr-2 flex-grow"
                }, blocks.map(block =>
                    React.createElement('div', {
                        key: block.id,
                        className: "p-3 rounded-md bg-slate-900 hover:bg-slate-700 transition-colors group"
                    }, [
                        React.createElement('div', { key: 'block-header', className: "flex items-start justify-between" }, [
                            React.createElement('div', {
                                key: 'block-info',
                                onClick: () => onViewBlock(block.id),
                                className: "flex items-center gap-3 overflow-hidden flex-grow cursor-pointer"
                            }, [
                                React.createElement('img', {
                                    key: 'image',
                                    className: "h-10 w-16 rounded object-cover flex-shrink-0",
                                    src: block.urlImagenBloque,
                                    alt: block.nombreCorto
                                }),
                                React.createElement('div', { key: 'details', className: "overflow-hidden" }, [
                                    React.createElement('p', {
                                        key: 'name',
                                        className: "font-semibold text-white truncate"
                                    }, block.nombreCorto),
                                    React.createElement('p', {
                                        key: 'meta',
                                        className: "text-xs text-gray-400 truncate"
                                    }, `por ${block.creatorNickname} ‚Ä¢ ${block.totalPreguntas} preguntas`)
                                ])
                            ]),
                            React.createElement('div', { key: 'block-actions', className: "flex items-center gap-1 flex-shrink-0" }, [
                                React.createElement('button', {
                                    key: 'expand',
                                    onClick: () => setExpandedBlockId(prev => prev === block.id ? null : block.id),
                                    className: "text-xs font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1 px-2 rounded-md transition-colors"
                                }, expandedBlockId === block.id ? 'Ocultar' : 'Ver Detalles'),
                                hasRole(currentUser, 'creador') && React.createElement('button', {
                                    key: 'edit',
                                    onClick: (e) => {
                                        e.stopPropagation();
                                        window.location.href = `block-questions.html?blockId=${block.id}&returnUrl=jugadores-panel-gaming.html&viewMode=edit`;
                                    },
                                    className: "p-2 rounded-full text-blue-400 hover:bg-blue-400/20 opacity-0 group-hover:opacity-100 transition-opacity"
                                }, '‚úèÔ∏è'),
                                React.createElement('button', {
                                    key: 'delete',
                                    onClick: (e) => {
                                        e.stopPropagation();
                                        handleDeleteClick(block.id);
                                    },
                                    className: "p-2 rounded-full text-red-400 hover:bg-red-400/20 opacity-0 group-hover:opacity-100 transition-opacity"
                                }, 'üóëÔ∏è')
                            ])
                        ]),
                        React.createElement('div', { key: 'progress', className: "mt-3" }, [
                            React.createElement('div', { key: 'progress-header', className: "flex justify-between items-center mb-1" }, [
                                React.createElement('span', {
                                    key: 'progress-label',
                                    className: "text-xs font-medium text-gray-400"
                                }, 'Progreso de Estudio'),
                                React.createElement('div', { key: 'progress-actions', className: "flex items-center gap-2" }, [
                                    React.createElement('span', {
                                        key: 'progress-value',
                                        className: "text-xs font-medium text-white"
                                    }, `${block.studyProgress ?? 0}%`),
                                    React.createElement('button', {
                                        key: 'stats',
                                        onClick: () => onOpenStatsModal && onOpenStatsModal(block),
                                        title: `Estad√≠sticas de ${block.nombreCorto}`,
                                        className: "text-xs font-bold bg-slate-600 hover:bg-gray-400 text-white py-1 px-3 rounded-md transition-colors"
                                    }, 'STAT')
                                ])
                            ]),
                            React.createElement('div', {
                                key: 'progress-bar-bg',
                                className: "w-full bg-slate-700 rounded-full h-1.5"
                            }, React.createElement('div', {
                                key: 'progress-bar-fill',
                                className: `${getProgressBarColor(block.studyProgress)} h-1.5 rounded-full transition-all duration-500`,
                                style: { width: `${block.studyProgress ?? 0}%` }
                            }))
                        ]),

                        expandedBlockId === block.id && React.createElement('div', {
                            key: 'expanded',
                            className: "mt-4 pt-4 border-t border-slate-600 space-y-2"
                        }, block.topicsWithStats && block.topicsWithStats.length > 0 ? 
                            block.topicsWithStats.map(topic =>
                                React.createElement('div', { key: topic.name }, [
                                    React.createElement('div', { key: 'topic-header', className: "flex justify-between mb-1" }, [
                                        React.createElement('span', {
                                            key: 'topic-name',
                                            className: "text-xs font-medium text-gray-400 truncate pr-2"
                                        }, topic.name),
                                        React.createElement('span', {
                                            key: 'topic-score',
                                            className: "text-xs font-medium text-white"
                                        }, `${topic.score}%`)
                                    ]),
                                    React.createElement('div', {
                                        key: 'topic-progress-bg',
                                        className: "w-full bg-slate-700 rounded-full h-1.5"
                                    }, React.createElement('div', {
                                        key: 'topic-progress-fill',
                                        className: `${getProgressBarColor(topic.score)} h-1.5 rounded-full transition-all duration-500`,
                                        style: { width: `${topic.score}%` }
                                    }))
                                ])
                            ) : 
                            React.createElement('p', {
                                key: 'no-topics',
                                className: "text-xs text-gray-400 text-center"
                            }, 'Este bloque no tiene temas con estad√≠sticas')
                        )
                    ])
                )) : React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-6 flex-grow flex items-center justify-center"
                }, React.createElement('div', { key: 'no-blocks-content' }, [
                    React.createElement('p', { key: 'no-blocks-text', className: "text-gray-400 mb-3" }, 'No hay bloques cargados'),
                    React.createElement('p', { key: 'no-blocks-hint', className: "text-gray-500 text-sm" }, [
                        hasRole(currentUser, 'creador') ? [
                            'Puedes ',
                            React.createElement('button', {
                                key: 'create-link',
                                onClick: () => window.location.href = './add-question.html',
                                className: "text-blue-400 hover:underline"
                            }, 'crear un nuevo bloque'),
                            ' o '
                        ] : null,
                        'cargar bloques desde ',
                        React.createElement('a', {
                            key: 'available-link',
                            href: "available-blocks.html",
                            className: "text-blue-400 hover:underline"
                        }, 'Bloques Disponibles')
                    ])
                ]))
            ]);
        };

        // Componente CreatedBlocksManagement para usuarios creadores
        const CreatedBlocksManagement = ({ blocks, setCurrentView, onDeleteBlock }) => {
            const { t } = useLanguage();
            const { currentUser } = useUser();
            const [confirmingDeleteId, setConfirmingDeleteId] = useState(null);

            const handleDeleteClick = (blockId) => {
                setConfirmingDeleteId(blockId);
            };

            const handleConfirmDelete = () => {
                if (confirmingDeleteId && onDeleteBlock) {
                    onDeleteBlock(confirmingDeleteId);
                    setConfirmingDeleteId(null);
                }
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            // Solo mostrar si el usuario es creador
            if (!hasRole(currentUser, 'creador')) {
                return null;
            }

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                confirmingDeleteId && React.createElement('div', {
                    key: 'confirm-dialog',
                    className: "fixed inset-0 bg-black/50 flex items-center justify-center z-50"
                }, React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-lg max-w-md mx-4"
                }, [
                    React.createElement('h3', { key: 'title', className: "text-lg font-bold text-white mb-4" }, 'Confirmar eliminaci√≥n'),
                    React.createElement('p', { key: 'message', className: "text-gray-300 mb-6" }, '¬øEst√°s seguro de que quieres eliminar este bloque creado?'),
                    React.createElement('div', { key: 'buttons', className: "flex gap-3 justify-end" }, [
                        React.createElement('button', {
                            key: 'cancel',
                            onClick: () => setConfirmingDeleteId(null),
                            className: "px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors"
                        }, 'Cancelar'),
                        React.createElement('button', {
                            key: 'confirm',
                            onClick: handleConfirmDelete,
                            className: "px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
                        }, 'Eliminar')
                    ])
                ])),

                React.createElement('div', {
                    key: 'header',
                    className: "flex items-center justify-between mb-4 flex-shrink-0"
                }, [
                    React.createElement('div', { key: 'title-section', className: "flex items-center" }, [
                        React.createElement('img', {
                            key: 'icon',
                            src: "./Imagenes/Creados.png",
                            alt: "Created Blocks",
                            className: "h-10 w-10 mr-3"
                        }),
                        React.createElement('h3', {
                            key: 'title',
                            className: "text-xl font-bold text-white"
                        }, 'Mis Bloques Creados')
                    ]),
                    React.createElement('a', {
                        key: 'manage-all',
                        href: "all-blocks.html",
                        className: "text-sm font-semibold bg-slate-600 hover:bg-slate-500 text-white py-1.5 px-3 rounded-md transition-colors"
                    }, `Gestionar (${blocks.length})`)
                ]),

                blocks.length > 0 ? React.createElement('div', {
                    key: 'blocks-list',
                    className: "space-y-3 overflow-y-auto max-h-96 pr-2 flex-grow"
                }, blocks.slice(0, 5).map(block =>
                    React.createElement('div', {
                        key: block.id,
                        className: "flex items-center justify-between p-3 rounded-md bg-slate-900 group"
                    }, [
                        React.createElement('div', {
                            key: 'block-content',
                            className: "flex items-center gap-3 overflow-hidden flex-grow"
                        }, [
                            React.createElement('img', {
                                key: 'image',
                                className: "h-10 w-16 rounded object-cover flex-shrink-0",
                                src: block.urlImagenBloque,
                                alt: block.nombreCorto
                            }),
                            React.createElement('div', { key: 'details', className: "overflow-hidden" }, [
                                React.createElement('p', {
                                    key: 'name',
                                    className: "font-semibold text-white truncate"
                                }, block.nombreCorto),
                                React.createElement('p', {
                                    key: 'questions',
                                    className: "text-xs text-gray-400"
                                }, `${block.totalPreguntas || block.questionCount || 0} preguntas`)
                            ])
                        ]),
                        React.createElement('div', {
                            key: 'actions',
                            className: "flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity"
                        }, [
                            React.createElement('button', {
                                key: 'edit',
                                onClick: () => window.location.href = `block-questions.html?blockId=${block.id}&returnUrl=jugadores-panel-gaming.html&viewMode=edit`,
                                className: "text-xs font-semibold bg-blue-600 hover:bg-blue-700 text-white py-1.5 px-3 rounded-md transition-colors"
                            }, 'Editar'),
                            React.createElement('button', {
                                key: 'delete',
                                onClick: () => handleDeleteClick(block.id),
                                className: "text-xs font-semibold bg-red-600/20 hover:bg-red-600/40 text-red-400 py-1.5 px-3 rounded-md transition-colors"
                            }, 'Eliminar')
                        ])
                    ])
                )) : React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-6 flex-grow flex items-center justify-center"
                }, React.createElement('div', { key: 'no-blocks-content' }, [
                    React.createElement('p', { key: 'no-blocks-text', className: "text-gray-400 mb-3" }, 'No has creado ning√∫n bloque'),
                    React.createElement('p', { key: 'no-blocks-hint', className: "text-sm text-gray-500" }, [
                        'Comienza ',
                        React.createElement('a', {
                            key: 'create-link',
                            href: './add-question.html',
                            className: "text-blue-400 hover:underline"
                        }, 'creando tu primer bloque'),
                        ' de preguntas'
                    ])
                ]))
            ]);
        };

        // Componente principal del dashboard de jugadores
        const PlayerDashboard = () => {
            const { t } = useLanguage();
            const [currentUser, setCurrentUser] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [blocks, setBlocks] = useState([]);
            const [createdBlocks, setCreatedBlocks] = useState([]);
            const [availableBlocks, setAvailableBlocks] = useState([]);
            const [loadedBlockIds, setLoadedBlockIds] = useState([]);
            const [games, setGames] = useState([]);
            const [gameConfigurations, setGameConfigurations] = useState([]);
            const [challenges, setChallenges] = useState([]);
            const [gameHistory, setGameHistory] = useState([]);
            const [allUsers, setAllUsers] = useState([]);
            const [error, setError] = useState(null);
            const [message, setMessage] = useState('');

            // Cargar datos del usuario desde localStorage
            useEffect(() => {
                const loadUserSession = () => {
                    try {
                        const sessionString = localStorage.getItem('playtest_session');
                        const token = localStorage.getItem('playtest_auth_token');
                        
                        if (sessionString && token) {
                            const session = JSON.parse(sessionString);
                            if (session && session.userId && session.nickname) {
                                setCurrentUser({
                                    id: session.userId,
                                    nickname: session.nickname
                                });
                                
                                // Configurar token en apiDataService si existe
                                if (window.apiDataService && !window.apiDataService.token) {
                                    window.apiDataService.token = token;
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error loading user session:', e);
                    } finally {
                        setIsLoading(false);
                    }
                };

                loadUserSession();
            }, []);

            // Cargar datos del jugador
            const loadPlayerData = useCallback(async () => {
                if (!currentUser) return;
                
                try {
                    setError(null);
                    setIsLoading(true);
                    
                    if (window.apiDataService) {
                        const [
                            fetchedGames,
                            fetchedGameConfigurations,
                            fetchedAllUsers,
                            fetchedChallenges,
                            fetchedHistory,
                            loadedBlocks,
                            fetchedCreatedBlocks,
                            fetchedAvailableBlocks,
                            userProfile
                        ] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchGameConfigurations(),
                            window.apiDataService.fetchAllUsers(),
                            window.apiDataService.fetchChallengesForUser(currentUser.id),
                            window.apiDataService.fetchGameHistory(currentUser.id),
                            window.apiDataService.fetchLoadedBlocks(),
                            window.apiDataService.fetchCreatedBlocks(),
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);

                        setGames(fetchedGames || []);
                        setGameConfigurations(fetchedGameConfigurations || []);
                        setAllUsers(fetchedAllUsers || []);
                        setChallenges(fetchedChallenges || []);
                        setGameHistory(fetchedHistory || []);
                        setBlocks(loadedBlocks || []);
                        setCreatedBlocks(fetchedCreatedBlocks || []);
                        setAvailableBlocks(fetchedAvailableBlocks || []);
                        setLoadedBlockIds((userProfile?.loadedBlocks || []).map(id => parseInt(id)));
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al cargar datos: ${err.message}` : 'Error desconocido.');
                } finally {
                    setIsLoading(false);
                }
            }, [currentUser]);

            useEffect(() => {
                loadPlayerData();
                // Make refresh function available globally for game configuration dashboard
                window.refreshPlayerDashboardData = loadPlayerData;
            }, [loadPlayerData]);

            // Navegaci√≥n a juegos
            const onNavigateToGame = (game) => {
                console.log('üéÆ PlayerDashboard - Navigating to game:', { id: game.id, mode: game.mode, status: game.status, fullGame: game });

                if (!game || !game.id) {
                    console.error('‚ùå PlayerDashboard - Cannot navigate - game or game.id is missing:', game);
                    alert('Error: No se puede continuar la partida. ID de juego no encontrado.');
                    return;
                }

                // For competition games (Duelo/Trivial), go directly to their specific pages
                if (game.mode === 'Duelo') {
                    console.log('ü•ä PlayerDashboard - Redirecting to Duelo game with ID:', game.id);
                    window.location.href = `game-duel.html?gameId=${game.id}`;
                } else if (game.mode === 'Trivial') {
                    console.log('üß† PlayerDashboard - Redirecting to Trivial game with ID:', game.id);
                    window.location.href = `game-trivial.html?gameId=${game.id}`;
                } else {
                    console.log('üéØ PlayerDashboard - Redirecting to generic active game with ID:', game.id);
                    window.location.href = `active-game.html?gameId=${game.id}`;
                }
            };

            // Crear nuevo juego
            const handleCreateGame = async (gameConfig) => {
                // DEBUG: Log received gameConfig
                console.log('üì® GAME DEBUG - handleCreateGame received:', {
                    gameConfig: gameConfig,
                    gameConfigType: typeof gameConfig,
                    gameConfigKeys: gameConfig ? Object.keys(gameConfig) : 'null',
                    hasMode: gameConfig?.mode,
                    hasConfig: gameConfig?.config,
                    configKeys: gameConfig?.config ? Object.keys(gameConfig.config) : 'no config'
                });
                
                try {
                    if (window.apiDataService) {
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            await loadPlayerData();
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al crear juego: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteGame = async (gameId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameForUser(currentUser.id, gameId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar juego: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleAcceptChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al aceptar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeclineChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.declineChallenge(currentUser.id, challengeId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al declinar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            // New enhanced function to accept challenge and start game directly
            const handleAcceptAndStartGame = async (challengeId, challenge) => {
                try {
                    if (window.apiDataService) {
                        console.log('üéÆ Accepting challenge and starting game:', { challengeId, challenge });
                        
                        // Accept the challenge (this changes status from 'pending' to 'active')
                        await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        
                        // Navigate directly to the game with the challenge's game ID
                        console.log('üöÄ Redirecting to game:', challengeId);
                        setCurrentView('game');
                        setCurrentGameId(challengeId);
                        
                        // Refresh data to remove the challenge from pending list
                        await loadPlayerData();
                        
                        setMessage(`¬°Reto aceptado! Iniciando partida...`);
                        setTimeout(() => setMessage(''), 2000);
                    }
                } catch (err) {
                    console.error('‚ùå Error accepting challenge and starting game:', err);
                    setError(err instanceof Error ? `Error al aceptar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            // New function to decline with reason and notify challenger
            const handleDeclineWithReason = async (challengeId, challengerNickname) => {
                const reason = prompt(
                    `¬øPor qu√© declinas el reto de ${challengerNickname}?\n\n(Opcional: Puedes dejar este campo vac√≠o o escribir una raz√≥n que ser√° enviada al retador)`
                );
                
                // Allow cancellation
                if (reason === null) return;
                
                try {
                    if (window.apiDataService) {
                        console.log('‚ùå Declining challenge with reason:', { challengeId, reason });
                        
                        // Send decline with reason to backend
                        await window.apiDataService.declineChallengeWithReason(currentUser.id, challengeId, reason || '');
                        
                        // Refresh data
                        await loadPlayerData();
                        
                        const message = reason 
                            ? `Reto declinado. Se ha enviado tu respuesta a ${challengerNickname}.`
                            : `Reto declinado.`;
                        setMessage(message);
                        setTimeout(() => setMessage(''), 3000);
                    }
                } catch (err) {
                    console.error('‚ùå Error declining challenge with reason:', err);
                    setError(err instanceof Error ? `Error al declinar reto: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteConfiguration = async (configId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameConfiguration(configId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar configuraci√≥n: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleRepeatConfiguration = async (config) => {
                try {
                    if (window.apiDataService) {
                        const gameConfig = { 
                            mode: config.game_type || config.gameType || 'Partida', 
                            config: config.configuration || config.config 
                        };
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            await loadPlayerData();
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al repetir configuraci√≥n: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleDeleteBlock = async (blockId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteLoadedBlock(blockId);
                        await loadPlayerData();
                    }
                } catch (err) {
                    setError(err instanceof Error ? `Error al eliminar bloque: ${err.message}` : 'Error desconocido.');
                }
            };

            const handleViewBlock = (blockId) => {
                window.location.href = `block-questions.html?blockId=${blockId}&returnUrl=jugadores-panel-gaming.html&viewMode=readonly`;
            };

            const handleOpenStatsModal = (block) => {
                // Implementar modal de estad√≠sticas o redirigir a p√°gina de estad√≠sticas
                console.log('Abrir estad√≠sticas para bloque:', block.nombreCorto);
            };

            const viewBlockQuestions = (blockId) => {
                window.location.href = `block-questions.html?blockId=${blockId}&returnUrl=jugadores-panel-gaming.html&viewMode=readonly`;
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "flex justify-center items-center h-64" 
                }, React.createElement('div', { 
                    className: "text-center text-white" 
                }, t('loading')));
            }

            if (error) {
                return React.createElement('div', { 
                    className: "text-center text-red-400 bg-red-500/10 p-4 rounded-lg m-4" 
                }, `${t('error')}: ${error}`);
            }

            if (!currentUser) {
                return React.createElement('div', { 
                    className: "text-center text-white p-4" 
                }, 'Usuario no encontrado. Regresa a la p√°gina de inicio.');
            }

            // Enviar reto
            const handleSendChallenge = async (challengedUser, gameConfig) => {
                console.log('üì® CHALLENGE DEBUG - handleSendChallenge received:', {
                    challengedUser: challengedUser,
                    gameConfig: gameConfig
                });

                try {
                    if (window.apiDataService) {
                        // CRITICAL FIX: Prepare shuffled questions BEFORE creating challenge
                        console.log('üé≤ [CHALLENGE] Preparing shuffled questions for duel...');
                        const allBlocks = await window.apiDataService.fetchAllBlocks();
                        let allQuestions = [];

                        // Collect questions based on config
                        for (const [blockId, blockConfig] of Object.entries(gameConfig.config)) {
                            const block = allBlocks.find(b => b.id === parseInt(blockId));
                            if (!block || !block.questions) {
                                console.warn(`‚ö†Ô∏è [CHALLENGE] Block ${blockId} not found or has no questions`);
                                continue;
                            }

                            const questionsWithMeta = block.questions.map(q => ({...q, blockId: block.id}));

                            if (blockConfig.topics === 'all') {
                                allQuestions.push(...questionsWithMeta);
                            } else if (Array.isArray(blockConfig.topics)) {
                                const filtered = questionsWithMeta.filter(q => blockConfig.topics.includes(q.tema));
                                allQuestions.push(...filtered);
                            }
                        }

                        console.log(`üìä [CHALLENGE] Total questions collected: ${allQuestions.length}`);

                        // Get the question count from gameConfig (default to 20 if not specified)
                        const questionCount = gameConfig.duelQuestionCount || 20;
                        console.log(`üéØ [CHALLENGE] Configured question count: ${questionCount}`);

                        // Shuffle questions and take only the configured amount
                        const shuffled = allQuestions.sort(() => Math.random() - 0.5).slice(0, questionCount);
                        const shuffledQuestionIds = shuffled.map(q => q.id);

                        console.log(`üîÄ [CHALLENGE] Questions shuffled: ${shuffledQuestionIds.length} IDs (limited to ${questionCount})`);

                        // Add shuffledQuestionIds to config
                        const enhancedConfig = {
                            ...gameConfig,
                            config: {
                                ...gameConfig.config,
                                shuffledQuestionIds: shuffledQuestionIds
                            }
                        };

                        console.log('‚úÖ [CHALLENGE] Enhanced config with shuffledQuestionIds:', enhancedConfig);

                        // Create challenge with enhanced config
                        await window.apiDataService.createChallenge(
                            currentUser,
                            challengedUser,
                            enhancedConfig
                        );

                        // Refresh data to show new challenge
                        await loadPlayerData();
                        console.log('‚úÖ Challenge sent successfully to:', challengedUser.nickname);

                        // Show success message
                        setMessage(`¬°Reto enviado exitosamente a ${challengedUser.nickname}!`);
                        setTimeout(() => setMessage(''), 3000);
                    }
                } catch (error) {
                    console.error('‚ùå Error sending challenge:', error);
                    setError('Error al enviar el reto. Int√©ntalo de nuevo.');
                }
            };

            return React.createElement('div', { 
                className: "container mx-auto px-4 py-6 space-y-8 animate-fade-in" 
            }, [
                // Message display
                message && React.createElement('div', {
                    key: 'message',
                    className: `mb-4 p-3 rounded-lg text-center ${message.includes('Error') ? 'bg-red-500/20 text-red-300' : 'bg-green-500/20 text-green-300'}`
                }, message),
                
                // Bienvenida
                // Componente principal
                React.createElement(GameSetup, {
                    key: 'game-setup',
                    blocks: blocks,
                    onCreateGame: handleCreateGame,
                    onSendChallenge: handleSendChallenge
                })
            ]);
        };

        // Aplicaci√≥n principal
        const App = () => {
            const [currentUser] = useState({ nickname: 'Jugador' }); // Simplificado para esta versi√≥n
            
            return React.createElement(LanguageProvider, {}, 
                React.createElement(UserContext.Provider, { value: { currentUser } },
                    React.createElement(PlayerDashboard, {})
                )
            );
        };

        // Renderizar la aplicaci√≥n principal solo en la pesta√±a de Partidas
        const root = ReactDOM.createRoot(document.getElementById('player-dashboard-root'));
        root.render(React.createElement(App));

        // Crear componentes completos y funcionales para las pesta√±as
        const TabBlocksComponent = () => {
            const [tabBlocks, setTabBlocks] = useState([]);
            const [tabCreatedBlocks, setTabCreatedBlocks] = useState([]);
            const [currentUser, setCurrentUser] = useState(null);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const loadBlocksData = async () => {
                    try {
                        setIsLoading(true);
                        const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                        
                        if (!window.apiDataService) {
                            setTimeout(loadBlocksData, 1000);
                            return;
                        }
                        
                        const userId = session.id || session.userId;
                        if (!userId) {
                            return;
                        }

                        setCurrentUser(session);
                        
                        const [blocks, createdBlocks] = await Promise.all([
                            window.apiDataService.fetchLoadedBlocks(),
                            window.apiDataService.fetchCreatedBlocks(userId)
                        ]);
                        
                        setTabBlocks(blocks || []);
                        setTabCreatedBlocks(createdBlocks || []);
                    } catch (error) {
                        console.error('Error loading blocks data:', error);
                    } finally {
                        setIsLoading(false);
                    }
                };
                loadBlocksData();
            }, []);

            const handleViewBlock = (blockId) => {
                window.location.href = `game-classic.html?blockId=${blockId}`;
            };

            const handleDeleteBlock = async (blockId) => {
                if (window.apiDataService && currentUser) {
                    try {
                        const userId = currentUser.id || currentUser.userId;
                        await window.apiDataService.deleteBlockForUser(userId, blockId);
                        setTabBlocks(prev => prev.filter(b => b.id !== blockId));
                        setTabCreatedBlocks(prev => prev.filter(b => b.id !== blockId));
                    } catch (error) {
                        console.error('Error deleting block:', error);
                    }
                }
            };

            const handleOpenStatsModal = () => {
                // Implementar modal de estad√≠sticas si es necesario
            };

            const hasRole = (user, role) => {
                if (!user) return false;
                if (user.roles && Array.isArray(user.roles)) {
                    return user.roles.includes(role);
                }
                return user.role === role || user.role_name === role;
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando bloques...')
                ]);
            }

            return React.createElement('div', { className: "space-y-6" }, [
                // UserBlockManagement completo
                React.createElement(UserBlockManagement, {
                    key: 'tab-user-block-management',
                    blocks: tabBlocks,
                    onViewBlock: handleViewBlock,
                    onDeleteBlock: handleDeleteBlock,
                    onOpenAddBlockModal: () => {},
                    onOpenStatsModal: handleOpenStatsModal,
                    setCurrentView: () => {}
                }),

                // CreatedBlocksManagement para usuarios creadores
                hasRole(currentUser, 'creador') && React.createElement(CreatedBlocksManagement, {
                    key: 'tab-created-blocks-management',
                    blocks: tabCreatedBlocks,
                    setCurrentView: () => {},
                    onDeleteBlock: handleDeleteBlock
                })
            ]);
        };

        // Componente AvailableBlocks completo (funcionalidades de available-blocks.html)
        const AvailableBlocksComponent = () => {
            const [availableBlocks, setAvailableBlocks] = useState([]);
            const [filteredBlocks, setFilteredBlocks] = useState([]);
            const [loadedBlockIds, setLoadedBlockIds] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [searchTerm, setSearchTerm] = useState('');
            const [loadingActions, setLoadingActions] = useState({});
            const [message, setMessage] = useState('');
            
            // Filtros de metadata
            const [blockMetadata, setBlockMetadata] = useState({ types: [], levels: [], states: [] });
            const [selectedTipo, setSelectedTipo] = useState('');
            const [selectedNivel, setSelectedNivel] = useState('');
            const [selectedEstado, setSelectedEstado] = useState('');

            useEffect(() => {
                loadData();
                loadMetadata();
            }, []);

            // Aplicar filtros cuando cambien los valores
            useEffect(() => {
                applyFilters();
            }, [availableBlocks, searchTerm, selectedTipo, selectedNivel, selectedEstado]);

            const loadData = async () => {
                try {
                    setIsLoading(true);
                    const currentUser = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                    
                    if (!window.apiDataService) {
                        setTimeout(loadData, 1000);
                        return;
                    }
                    
                    const userId = currentUser.id || currentUser.userId;
                    if (!userId) {
                        return;
                    }

                    const [available, profile] = await Promise.all([
                        window.apiDataService.fetchAvailableBlocks(),
                        window.apiDataService.getUserProfile()
                    ]);
                    
                    setAvailableBlocks(available || []);
                    setLoadedBlockIds(profile?.loadedBlocks || []);
                } catch (error) {
                    console.error('Error loading available blocks:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleLoadBlock = async (blockId) => {
                setLoadingActions(prev => ({ ...prev, [blockId]: 'loading' }));
                try {
                    await window.apiDataService.loadBlock(blockId);
                    setMessage('Bloque cargado exitosamente');
                    await loadData(); // Refresh blocks data
                    // Also refresh games data since available questions may have changed
                    if (window.refreshActiveGamesData) {
                        await window.refreshActiveGamesData();
                    }
                    // Refresh game configuration dashboard as well
                    if (window.refreshPlayerDashboardData) {
                        await window.refreshPlayerDashboardData();
                    }
                } catch (error) {
                    console.error('Error loading block:', error);
                    setMessage('Error al cargar el bloque');
                } finally {
                    setLoadingActions(prev => ({ ...prev, [blockId]: null }));
                    setTimeout(() => setMessage(''), 3000);
                }
            };

            const handleUnloadBlock = async (blockId) => {
                setLoadingActions(prev => ({ ...prev, [blockId]: 'unloading' }));
                try {
                    await window.apiDataService.unloadBlock(blockId);
                    setMessage('Bloque descargado exitosamente');
                    await loadData(); // Refresh blocks data
                    // Also refresh games data since available questions may have changed
                    if (window.refreshActiveGamesData) {
                        await window.refreshActiveGamesData();
                    }
                    // Refresh game configuration dashboard as well
                    if (window.refreshPlayerDashboardData) {
                        await window.refreshPlayerDashboardData();
                    }
                } catch (error) {
                    console.error('Error unloading block:', error);
                    setMessage('Error al descargar el bloque');
                } finally {
                    setLoadingActions(prev => ({ ...prev, [blockId]: null }));
                    setTimeout(() => setMessage(''), 3000);
                }
            };

            const loadMetadata = async () => {
                try {
                    console.log('üîç Loading metadata for filters...');
                    const metadata = await window.apiDataService.fetchBlockMetadata();
                    console.log('‚úÖ Loaded metadata:', metadata);
                    setBlockMetadata(metadata);
                } catch (error) {
                    console.error('‚ùå Error loading metadata for filters:', error);
                }
            };

            const applyFilters = () => {
                if (!availableBlocks.length) {
                    setFilteredBlocks([]);
                    return;
                }

                let filtered = availableBlocks.filter(block =>
                    block.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    block.creatorNickname?.toLowerCase().includes(searchTerm.toLowerCase())
                );

                // Aplicar filtros de metadata
                if (selectedTipo) {
                    filtered = filtered.filter(block => block.tipo_id == selectedTipo);
                }
                
                if (selectedNivel) {
                    filtered = filtered.filter(block => block.nivel_id == selectedNivel);
                }
                
                if (selectedEstado) {
                    filtered = filtered.filter(block => block.estado_id == selectedEstado);
                }

                console.log(`üîç Filtered ${filtered.length} blocks from ${availableBlocks.length} total`);
                setFilteredBlocks(filtered);
            };

            const clearFilters = () => {
                console.log('üóëÔ∏è Clearing all filters');
                setSearchTerm('');
                setSelectedTipo('');
                setSelectedNivel('');
                setSelectedEstado('');
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando bloques disponibles...')
                ]);
            }

            return React.createElement('div', { className: "bg-slate-800 p-6 rounded-xl shadow-lg" }, [
                // Message display
                message && React.createElement('div', {
                    key: 'message',
                    className: `mb-4 p-3 rounded-lg text-center ${message.includes('Error') ? 'bg-red-500/20 text-red-300' : 'bg-green-500/20 text-green-300'}`
                }, message),

                // Search bar
                React.createElement('div', {
                    key: 'search-container',
                    className: "mb-6"
                }, React.createElement('div', {
                    className: "relative"
                }, [
                    React.createElement('input', {
                        key: 'search-input',
                        type: "text",
                        placeholder: "Buscar bloques...",
                        value: searchTerm,
                        onChange: (e) => setSearchTerm(e.target.value),
                        className: "w-full px-4 py-2 pl-10 bg-slate-700 border border-slate-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-blue-500"
                    }),
                    React.createElement('svg', {
                        key: 'search-icon',
                        className: "absolute left-3 top-3 h-4 w-4 text-gray-400",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                    }, React.createElement('path', {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                    }))
                ])),

                // Filtros de Metadata
                React.createElement('div', {
                    key: 'metadata-filters',
                    className: "mb-6 p-4 bg-slate-700 rounded-lg border border-slate-600"
                }, [
                    React.createElement('h4', {
                        key: 'filters-title',
                        className: "text-sm font-medium text-gray-300 mb-3"
                    }, 'üîç Filtros'),
                    
                    React.createElement('div', {
                        key: 'filters-grid',
                        className: "grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4"
                    }, [
                        // Filtro Tipo
                        React.createElement('div', { key: 'tipo-filter' }, [
                            React.createElement('label', {
                                key: 'tipo-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Tipo de Bloque'),
                            React.createElement('select', {
                                key: 'tipo-select',
                                value: selectedTipo,
                                onChange: (e) => setSelectedTipo(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'tipo-all', value: '' }, 'Todos los tipos'),
                                ...blockMetadata.types.map(tipo => 
                                    React.createElement('option', { key: `tipo-${tipo.id}`, value: tipo.id }, tipo.name)
                                )
                            ])
                        ]),
                        
                        // Filtro Nivel
                        React.createElement('div', { key: 'nivel-filter' }, [
                            React.createElement('label', {
                                key: 'nivel-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Nivel'),
                            React.createElement('select', {
                                key: 'nivel-select',
                                value: selectedNivel,
                                onChange: (e) => setSelectedNivel(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'nivel-all', value: '' }, 'Todos los niveles'),
                                ...blockMetadata.levels.map(nivel => 
                                    React.createElement('option', { key: `nivel-${nivel.id}`, value: nivel.id }, nivel.name)
                                )
                            ])
                        ]),
                        
                        // Filtro Car√°cter/Estado
                        React.createElement('div', { key: 'estado-filter' }, [
                            React.createElement('label', {
                                key: 'estado-label',
                                className: "block text-xs text-gray-400 mb-1"
                            }, 'Car√°cter'),
                            React.createElement('select', {
                                key: 'estado-select',
                                value: selectedEstado,
                                onChange: (e) => setSelectedEstado(e.target.value),
                                className: "w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md text-white text-sm focus:outline-none focus:border-blue-500"
                            }, [
                                React.createElement('option', { key: 'estado-all', value: '' }, 'Todos los caracteres'),
                                ...blockMetadata.states.map(estado => 
                                    React.createElement('option', { key: `estado-${estado.id}`, value: estado.id }, estado.name)
                                )
                            ])
                        ]),
                        
                        // Bot√≥n limpiar filtros
                        React.createElement('div', { key: 'clear-filter-container', className: "flex items-end" }, [
                            React.createElement('button', {
                                key: 'clear-filters-btn',
                                onClick: clearFilters,
                                className: "w-full px-3 py-2 bg-red-600 hover:bg-red-700 text-white text-sm rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-red-500"
                            }, 'üóëÔ∏è Limpiar')
                        ])
                    ])
                ]),

                // Blocks grid
                filteredBlocks.length === 0 ? React.createElement('div', {
                    key: 'no-blocks',
                    className: "text-center py-12"
                }, React.createElement('p', {
                    className: "text-gray-400 text-lg"
                }, searchTerm ? 'No se encontraron bloques que coincidan con la b√∫squeda' : 'No hay bloques disponibles')) : 
                React.createElement('div', {
                    key: 'blocks-grid',
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"
                }, filteredBlocks.map(block => {
                    const isLoaded = loadedBlockIds.includes(block.id);
                    const actionLoading = loadingActions[block.id];
                    
                    return React.createElement('div', {
                        key: block.id,
                        className: "bg-slate-700 p-4 rounded-lg border border-slate-600 hover:border-slate-500 transition-colors"
                    }, [
                        React.createElement('div', {
                            key: 'block-header',
                            className: "flex justify-between items-start mb-3"
                        }, [
                            React.createElement('h3', {
                                key: 'block-name',
                                className: "font-semibold text-white text-lg leading-tight pr-2"
                            }, block.name),
                            isLoaded && React.createElement('span', {
                                key: 'loaded-badge',
                                className: "text-xs bg-green-500/20 text-green-300 px-2 py-1 rounded-full flex-shrink-0"
                            }, 'Cargado')
                        ]),
                        
                        React.createElement('p', {
                            key: 'block-description',
                            className: "text-gray-400 text-sm mb-3 line-clamp-2"
                        }, block.description || 'Sin descripci√≥n'),
                        
                        React.createElement('div', {
                            key: 'block-info',
                            className: "flex justify-between items-center mb-4 text-xs text-gray-500"
                        }, [
                            React.createElement('span', {
                                key: 'questions-count'
                            }, `${block.questionCount || 0} preguntas`),
                            React.createElement('span', {
                                key: 'creator'
                            }, `por ${block.creatorNickname || 'Usuario'}`)
                        ]),
                        
                        React.createElement('button', {
                            key: 'action-button',
                            onClick: () => isLoaded ? handleUnloadBlock(block.id) : handleLoadBlock(block.id),
                            disabled: !!actionLoading,
                            className: `w-full py-2 px-4 rounded-md font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${
                                isLoaded
                                    ? 'bg-red-500/20 text-red-300 hover:bg-red-500/30'
                                    : 'bg-blue-600 hover:bg-blue-700 text-white'
                            }`
                        }, actionLoading ? React.createElement('div', {
                            className: "flex items-center justify-center"
                        }, [
                            React.createElement('div', {
                                key: 'action-spinner',
                                className: "animate-spin rounded-full h-4 w-4 border-b-2 border-current mr-2"
                            }),
                            actionLoading === 'loading' ? 'Cargando...' : 'Descargando...'
                        ]) : (isLoaded ? 'Descargar' : 'Cargar'))
                    ]);
                }))
            ]);
        };

        // Componente ActiveGames separado para la secci√≥n Juegos Activos  
        const ActiveGamesComponent = () => {
            const [games, setGames] = useState([]);
            const [gameConfigurations, setGameConfigurations] = useState([]);
            const [challenges, setChallenges] = useState([]);
            const [blocks, setBlocks] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [currentUser, setCurrentUser] = useState(null);

            const loadActiveGamesData = async () => {
                try {
                    setIsLoading(true);
                    const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                    
                    if (!window.apiDataService) {
                        setTimeout(loadActiveGamesData, 1000);
                        return;
                    }
                    
                    const userId = session.id || session.userId;
                    if (!userId) {
                        return;
                    }

                    setCurrentUser(session);
                    
                    const [gamesData, configurations, challengesData, blocksData] = await Promise.all([
                        window.apiDataService.fetchGamesForUser(userId),
                        window.apiDataService.fetchGameConfigurations(userId),
                        window.apiDataService.fetchChallengesForUser(userId),
                        window.apiDataService.fetchLoadedBlocks()
                    ]);
                    
                    setGames(gamesData || []);
                    setGameConfigurations(configurations || []);
                    setChallenges(challengesData || []);
                    setBlocks(blocksData || []);
                } catch (error) {
                    console.error('Error loading active games data:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            useEffect(() => {
                loadActiveGamesData();
                // Make refresh function available globally
                window.refreshActiveGamesData = loadActiveGamesData;
            }, []);

            const onNavigateToGame = (game) => {
                console.log('üéÆ [NAV] ==================== NAVEGANDO A JUEGO ====================');
                console.log('üéÆ [NAV] Juego completo recibido:', game);
                console.log('üÜî [NAV] Game ID:', game?.id);
                console.log('üéØ [NAV] Modo de juego:', game?.mode);
                console.log('üìä [NAV] Estado:', game?.status);
                console.log('‚öôÔ∏è [NAV] Configuraci√≥n:', game?.config);

                // Guardar informaci√≥n de navegaci√≥n en localStorage
                const navInfo = {
                    timestamp: new Date().toISOString(),
                    gameId: game?.id,
                    mode: game?.mode,
                    status: game?.status,
                    config: game?.config,
                    fullGame: game
                };
                localStorage.setItem('last_navigation_info', JSON.stringify(navInfo));

                // Update current_game_id with the latest game ID
                localStorage.setItem('current_game_id', game?.id);
                console.log('üíæ [NAV] Updated current_game_id in localStorage:', game?.id);

                if (!game || !game.id) {
                    console.error('‚ùå [NAV] Cannot navigate - game or game.id is missing:', game);
                    alert('Error: No se puede continuar la partida. ID de juego no encontrado.');
                    return;
                }

                // For competition games (Duelo/Trivial), go directly to their specific pages
                if (game.mode === 'Duelo') {
                    const targetUrl = `game-duel.html?gameId=${game.id}`;
                    console.log('ü•ä [NAV] Modo DUELO detectado');
                    console.log('üåê [NAV] URL destino:', targetUrl);
                    console.log('‚è∞ [NAV] Navegando a las:', new Date().toISOString());
                    window.location.href = targetUrl;
                } else if (game.mode === 'Trivial') {
                    const targetUrl = `game-trivial.html?gameId=${game.id}`;
                    console.log('üß† [NAV] Modo TRIVIAL detectado');
                    console.log('üåê [NAV] URL destino:', targetUrl);
                    console.log('‚è∞ [NAV] Navegando a las:', new Date().toISOString());
                    window.location.href = targetUrl;
                } else {
                    const targetUrl = `active-game.html?gameId=${game.id}`;
                    console.log('üéØ [NAV] Modo gen√©rico detectado');
                    console.log('üåê [NAV] URL destino:', targetUrl);
                    console.log('‚è∞ [NAV] Navegando a las:', new Date().toISOString());
                    window.location.href = targetUrl;
                }
            };

            const handleDeleteGame = async (gameId) => {
                try {
                    if (window.apiDataService && currentUser) {
                        const userId = currentUser.id || currentUser.userId;
                        await window.apiDataService.deleteGameForUser(userId, gameId);
                        setGames(prev => prev.filter(g => g.id !== gameId));
                    }
                } catch (error) {
                    console.error('Error deleting game:', error);
                }
            };

            const handleAcceptChallenge = async (challengeId) => {
                // Guardar logs en array
                const challengeLogs = [];
                const originalLog = console.log;
                const originalError = console.error;

                console.log = (...args) => {
                    challengeLogs.push({ type: 'log', timestamp: new Date().toISOString(), args: args.map(a => JSON.stringify(a, null, 2)) });
                    originalLog.apply(console, args);
                };
                console.error = (...args) => {
                    challengeLogs.push({ type: 'error', timestamp: new Date().toISOString(), args: args.map(a => JSON.stringify(a, null, 2)) });
                    originalError.apply(console, args);
                };

                console.log('üéØ [CHALLENGE] Aceptando reto:', challengeId);
                console.log('üë§ [CHALLENGE] Usuario actual:', currentUser);

                try {
                    if (window.apiDataService) {
                        console.log('üì° [CHALLENGE] Llamando a acceptChallenge...');
                        const result = await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        console.log('‚úÖ [CHALLENGE] Reto aceptado, resultado:', result);

                        // Recargar datos
                        console.log('üîÑ [CHALLENGE] Recargando juegos y retos...');
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);

                        console.log('üìä [CHALLENGE] Datos recargados:');
                        console.log('  - Juegos:', gamesData?.length || 0);
                        console.log('  - Retos:', challengesData?.length || 0);

                        setGames(gamesData || []);
                        setChallenges(challengesData || []);

                        console.log('‚úÖ [CHALLENGE] Estado actualizado');

                        // Guardar logs en localStorage
                        localStorage.setItem('challenge_accept_logs', JSON.stringify(challengeLogs));

                        // Restaurar console
                        console.log = originalLog;
                        console.error = originalError;
                    } else {
                        console.error('‚ùå [CHALLENGE] apiDataService no disponible');
                    }
                } catch (error) {
                    console.error('‚ùå [CHALLENGE] Error aceptando reto:', error);
                    console.error('üìã [CHALLENGE] Detalles del error:', {
                        message: error.message,
                        stack: error.stack
                    });

                    // Guardar logs en localStorage incluso en caso de error
                    localStorage.setItem('challenge_accept_logs', JSON.stringify(challengeLogs));

                    // Restaurar console
                    console.log = originalLog;
                    console.error = originalError;
                }
            };

            const handleDeclineChallenge = async (challengeId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.declineChallenge(currentUser.id, challengeId);
                        // Recargar datos - refresh BOTH games and challenges
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);
                        setGames(gamesData || []);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('Error declining challenge:', error);
                }
            };

            // Enhanced decline with reason for ActiveGamesComponent
            const handleDeclineWithReason = async (challengeId, challengerNickname) => {
                const reason = prompt(
                    `¬øPor qu√© declinas el reto de ${challengerNickname}?\n\n(Opcional: Puedes dejar este campo vac√≠o o escribir una raz√≥n que ser√° enviada al retador)`
                );
                
                // Allow cancellation
                if (reason === null) return;
                
                try {
                    if (window.apiDataService) {
                        console.log('‚ùå Declining challenge with reason:', { challengeId, reason });
                        
                        // Send decline with reason to backend
                        await window.apiDataService.declineChallengeWithReason(currentUser.id, challengeId, reason || '');

                        // Recargar datos - refresh BOTH games and challenges
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);
                        setGames(gamesData || []);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('‚ùå Error declining challenge with reason:', error);
                }
            };

            // Enhanced accept to start game for ActiveGamesComponent
            const handleAcceptAndStartGame = async (challengeId, challenge) => {
                try {
                    if (window.apiDataService && onNavigateToGame) {
                        console.log('üéÆ Accepting challenge and starting game:', { challengeId, challenge });

                        // Accept the challenge (this changes status from 'waiting' to 'active')
                        const response = await window.apiDataService.acceptChallenge(currentUser.id, challengeId);
                        console.log('‚úÖ Challenge accepted, response:', response);

                        // Extract game from response or fallback to challenge data
                        const acceptedGame = response?.game || { ...challenge, id: challengeId, status: 'active' };
                        console.log('üéØ Game object for navigation:', acceptedGame);

                        // Navigate directly to the game with the full game object
                        console.log('üöÄ Redirecting to game with full object');
                        onNavigateToGame(acceptedGame);

                        // Refresh data to remove the challenge from pending list
                        const [gamesData, challengesData] = await Promise.all([
                            window.apiDataService.fetchGamesForUser(currentUser.id),
                            window.apiDataService.fetchChallengesForUser(currentUser.id)
                        ]);
                        setGames(gamesData || []);
                        setChallenges(challengesData || []);
                    }
                } catch (error) {
                    console.error('‚ùå Error accepting challenge and starting game:', error);
                }
            };

            const handleDeleteConfiguration = async (configId) => {
                try {
                    if (window.apiDataService) {
                        await window.apiDataService.deleteGameConfiguration(configId);
                        const configurations = await window.apiDataService.fetchGameConfigurations(currentUser.id);
                        setGameConfigurations(configurations || []);
                    }
                } catch (error) {
                    console.error('Error deleting configuration:', error);
                }
            };

            const handleRepeatConfiguration = async (config) => {
                try {
                    if (window.apiDataService && currentUser) {
                        const gameConfig = { 
                            mode: config.game_type || config.gameType || 'Partida', 
                            config: config.configuration || config.config 
                        };
                        const newGame = await window.apiDataService.createGameForUser(
                            currentUser.id, 
                            currentUser.nickname, 
                            gameConfig
                        );
                        
                        if (newGame && newGame.id) {
                            localStorage.setItem('current_game_id', newGame.id);
                            localStorage.setItem('current_game_mode', 'normal');
                            onNavigateToGame(newGame);
                        }
                    }
                } catch (error) {
                    console.error('Error repeating configuration:', error);
                }
            };

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando juegos activos...')
                ]);
            }

            return React.createElement(ActiveGames, {
                games: games,
                gameConfigurations: gameConfigurations,
                challenges: challenges,
                blocks: blocks,
                onDeleteGame: handleDeleteGame,
                onNavigateToGame: onNavigateToGame,
                onAcceptChallenge: handleAcceptChallenge,
                onDeclineChallenge: handleDeclineChallenge,
                handleDeleteConfiguration: handleDeleteConfiguration,
                onRepeatConfiguration: handleRepeatConfiguration,
                setCurrentView: () => {}
            });
        };

        const TabHistoryComponent = () => {
            const [tabGameHistory, setTabGameHistory] = useState([]);
            const [isLoading, setIsLoading] = useState(true);

            useEffect(() => {
                const loadHistory = async () => {
                    try {
                        setIsLoading(true);
                        const currentUser = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                        
                        if (!window.apiDataService) {
                            setTimeout(loadHistory, 1000);
                            return;
                        }
                        
                        const userId = currentUser.id || currentUser.userId;
                        if (!userId) {
                            return;
                        }

                        const history = await window.apiDataService.fetchGameHistory(userId);
                        setTabGameHistory(history || []);
                    } catch (error) {
                        console.error('Error loading game history:', error);
                    } finally {
                        setIsLoading(false);
                    }
                };
                loadHistory();
            }, []);

            if (isLoading) {
                return React.createElement('div', { 
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center" 
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando historial...')
                ]);
            }

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg flex flex-col"
            }, [
                tabGameHistory && tabGameHistory.length > 0 ? React.createElement('div', {
                    key: 'history-table-container',
                    className: "overflow-x-auto overflow-y-auto flex-grow",
                    style: { maxHeight: '600px' }
                }, React.createElement('table', {
                    key: 'history-table',
                    className: "w-full text-sm"
                }, [
                    React.createElement('thead', { key: 'thead', className: "sticky top-0 bg-slate-800 z-10" }, React.createElement('tr', {
                        key: 'header-row',
                        className: "border-b border-slate-600"
                    }, [
                        React.createElement('th', { key: 'block-header', className: "py-2 px-2 text-left text-gray-300 font-semibold truncate bg-slate-800" }, 'Bloque'),
                        React.createElement('th', { key: 'mode-header', className: "py-2 px-2 text-left text-gray-300 font-semibold bg-slate-800" }, 'Modo'),
                        React.createElement('th', { key: 'correct-header', className: "py-2 px-2 text-center text-gray-300 font-semibold bg-slate-800" }, 'Aciertos'),
                        React.createElement('th', { key: 'incorrect-header', className: "py-2 px-2 text-center text-gray-300 font-semibold bg-slate-800" }, 'Fallos'),
                        React.createElement('th', { key: 'blank-header', className: "py-2 px-2 text-center text-gray-300 font-semibold bg-slate-800" }, 'Blancos'),
                        React.createElement('th', { key: 'score-header', className: "py-2 px-2 text-center text-gray-300 font-semibold bg-slate-800" }, 'Punt.'),
                        React.createElement('th', { key: 'date-header', className: "py-2 px-2 text-left text-gray-300 font-semibold bg-slate-800" }, 'Fecha')
                    ])),
                    React.createElement('tbody', { key: 'tbody' }, tabGameHistory.map((game, index) =>
                        React.createElement('tr', {
                            key: `game-${game.gameId || index}-${game.date || Date.now()}-${index}`,
                            className: "border-b border-slate-600"
                        }, [
                            React.createElement('td', {
                                key: 'block-name',
                                className: "py-3 px-2 text-white truncate max-w-32",
                                title: game.blockName
                            }, game.blockName),
                            React.createElement('td', { key: 'mode-info', className: "py-3 px-2 text-gray-400" },
                                React.createElement('div', { key: 'game-mode', className: "text-white" }, game.mode || 'Cl√°sico')
                            ),
                            React.createElement('td', { key: 'correct-cell', className: "py-3 px-2 text-center text-green-400 font-semibold" }, Math.floor(game.correct || 0)),
                            React.createElement('td', { key: 'incorrect-cell', className: "py-3 px-2 text-center text-red-400 font-semibold" }, Math.floor(game.incorrect || 0)),
                            React.createElement('td', { key: 'blank-cell', className: "py-3 px-2 text-center text-gray-400 font-semibold" }, Math.floor(game.blank || 0)),
                            React.createElement('td', { key: 'score-cell', className: "py-3 px-2 text-center" }, React.createElement('span', {
                                key: 'score-value',
                                className: "font-bold px-2 py-1 rounded text-xs",
                                style: { color: game.score >= 5 ? '#10B981' : '#EF4444' }
                            }, game.score ? game.score.toFixed(1) : '0.0')),
                            React.createElement('td', { key: 'date-cell', className: "py-3 px-2 text-gray-400 text-xs" }, (() => {
                                const date = new Date(game.date || Date.now());
                                return `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;
                            })())
                        ])
                    ))
                ])) : React.createElement('div', {
                    key: 'no-history',
                    className: "text-center text-gray-400 py-8"
                }, 'No hay historial de partidas')
            ]);
        };

        // Componente de Rankings Globales
        const GlobalRankingsComponent = () => {
            const [userBlocks, setUserBlocks] = useState([]);
            const [selectedBlock, setSelectedBlock] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);
            const [isLoadingBlocks, setIsLoadingBlocks] = useState(true);
            const [isLoadingLeaderboard, setIsLoadingLeaderboard] = useState(false);
            const [viewMode, setViewMode] = useState('block'); // 'block' o 'topic'

            useEffect(() => {
                const loadUserBlocks = async () => {
                    try {
                        setIsLoadingBlocks(true);

                        if (!window.apiDataService) {
                            setTimeout(loadUserBlocks, 1000);
                            return;
                        }

                        const blocks = await window.apiDataService.fetchUserBlocks();
                        setUserBlocks(blocks || []);

                        // Seleccionar el primer bloque por defecto
                        if (blocks && blocks.length > 0) {
                            setSelectedBlock(blocks[0]);
                        }
                    } catch (error) {
                        console.error('Error loading user blocks:', error);
                    } finally {
                        setIsLoadingBlocks(false);
                    }
                };
                loadUserBlocks();
            }, []);

            useEffect(() => {
                const loadLeaderboard = async () => {
                    if (!selectedBlock || !window.apiDataService) return;

                    try {
                        setIsLoadingLeaderboard(true);
                        const data = await window.apiDataService.fetchBlockLeaderboard(selectedBlock.id);
                        setLeaderboard(data || []);
                    } catch (error) {
                        console.error('Error loading leaderboard:', error);
                        setLeaderboard([]);
                    } finally {
                        setIsLoadingLeaderboard(false);
                    }
                };
                loadLeaderboard();
            }, [selectedBlock]);

            const handleBlockChange = (e) => {
                const blockId = parseInt(e.target.value);
                const block = userBlocks.find(b => b.id === blockId);
                setSelectedBlock(block);
            };

            const formatDate = (dateString) => {
                if (!dateString) return 'N/A';
                const date = new Date(dateString);
                return `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;
            };

            if (isLoadingBlocks) {
                return React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center"
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando bloques...')
                ]);
            }

            if (!userBlocks || userBlocks.length === 0) {
                return React.createElement('div', {
                    className: "bg-slate-800 p-6 rounded-xl shadow-lg text-center text-gray-400"
                }, 'No has jugado ning√∫n bloque todav√≠a. Completa algunas partidas para ver los rankings globales.');
            }

            return React.createElement('div', {
                className: "bg-slate-800 p-6 rounded-xl shadow-lg"
            }, [
                // Selector de bloque
                React.createElement('div', {
                    key: 'block-selector',
                    className: "mb-6"
                }, [
                    React.createElement('label', {
                        key: 'label',
                        className: "block text-gray-300 font-semibold mb-2"
                    }, 'Selecciona un bloque:'),
                    React.createElement('select', {
                        key: 'select',
                        className: "w-full bg-slate-700 text-white px-4 py-2 rounded-lg border border-slate-600 focus:outline-none focus:border-blue-500",
                        value: selectedBlock ? selectedBlock.id : '',
                        onChange: handleBlockChange
                    }, userBlocks.map(block =>
                        React.createElement('option', {
                            key: block.id,
                            value: block.id
                        }, `${block.name} (${block.game_count} partidas)`)
                    ))
                ]),

                // T√≠tulo del ranking
                selectedBlock && React.createElement('h3', {
                    key: 'ranking-title',
                    className: "text-xl font-bold text-white mb-4"
                }, `üèÜ Top 10 - ${selectedBlock.name}`),

                // Tabla de ranking
                isLoadingLeaderboard ? React.createElement('div', {
                    key: 'loading',
                    className: "text-center py-8"
                }, [
                    React.createElement('div', {
                        key: 'spinner',
                        className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4"
                    }),
                    React.createElement('p', {
                        key: 'loading-text',
                        className: "text-gray-400"
                    }, 'Cargando ranking...')
                ]) : leaderboard && leaderboard.length > 0 ? React.createElement('div', {
                    key: 'leaderboard-container',
                    className: "overflow-x-auto"
                }, React.createElement('table', {
                    className: "w-full text-sm"
                }, [
                    React.createElement('thead', { key: 'thead' }, React.createElement('tr', {
                        className: "border-b border-slate-600"
                    }, [
                        React.createElement('th', { key: 'rank', className: "py-2 px-2 text-center text-gray-300 font-semibold" }, 'Pos.'),
                        React.createElement('th', { key: 'user', className: "py-2 px-3 text-left text-gray-300 font-semibold" }, 'Usuario'),
                        React.createElement('th', { key: 'score', className: "py-2 px-2 text-center text-gray-300 font-semibold" }, 'Punt.'),
                        React.createElement('th', { key: 'correct', className: "py-2 px-2 text-center text-gray-300 font-semibold" }, 'Aciertos'),
                        React.createElement('th', { key: 'incorrect', className: "py-2 px-2 text-center text-gray-300 font-semibold" }, 'Fallos'),
                        React.createElement('th', { key: 'mode', className: "py-2 px-3 text-left text-gray-300 font-semibold" }, 'Modo'),
                        React.createElement('th', { key: 'date', className: "py-2 px-2 text-left text-gray-300 font-semibold" }, 'Fecha')
                    ])),
                    React.createElement('tbody', { key: 'tbody' }, leaderboard.map((entry, index) =>
                        React.createElement('tr', {
                            key: `entry-${index}-${entry.nickname}`,
                            className: "border-b border-slate-600"
                        }, [
                            React.createElement('td', {
                                key: 'rank-cell',
                                className: "py-3 px-2 text-center font-bold text-white"
                            }, index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}`),
                            React.createElement('td', {
                                key: 'user-cell',
                                className: "py-3 px-3 font-medium text-white"
                            }, entry.nickname),
                            React.createElement('td', {
                                key: 'score-cell',
                                className: "py-3 px-2 text-center"
                            }, React.createElement('span', {
                                className: "font-bold px-2 py-1 rounded text-xs",
                                style: { color: entry.score >= 5 ? '#10B981' : '#EF4444' }
                            }, entry.score ? entry.score.toFixed(1) : '0.0')),
                            React.createElement('td', {
                                key: 'correct-cell',
                                className: "py-3 px-2 text-center text-green-400 font-semibold"
                            }, entry.correct || 0),
                            React.createElement('td', {
                                key: 'incorrect-cell',
                                className: "py-3 px-2 text-center text-red-400 font-semibold"
                            }, entry.incorrect || 0),
                            React.createElement('td', {
                                key: 'mode-cell',
                                className: "py-3 px-3 text-gray-400"
                            }, entry.gameMode || entry.gameType || 'Cl√°sico'),
                            React.createElement('td', {
                                key: 'date-cell',
                                className: "py-3 px-2 text-gray-400 text-xs"
                            }, formatDate(entry.date))
                        ])
                    ))
                ])) : React.createElement('div', {
                    key: 'no-data',
                    className: "text-center text-gray-400 py-8"
                }, 'No hay datos de ranking disponibles para este bloque.')
            ]);
        };

        // Datos globales para los bloques disponibles
        let availableBlocksData = [];
        let availableBlocksMetadata = null;

        // Crear componente de Bloques Disponibles mejorado con filtros
        const createAvailableBlocksComponent = async () => {
            const container = document.getElementById('available-blocks-pjg-container');
            if (!container || !window.apiDataService) return;

            try {
                // Mostrar loading
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #778DA9;">
                        <div style="animation: spin 1s linear infinite; border: 2px solid #415A77; border-top: 2px solid #3B82F6; border-radius: 50%; width: 40px; height: 40px; margin: 0 auto 20px;"></div>
                        <p>Cargando bloques disponibles...</p>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;

                // Cargar datos en paralelo
                const [blocks, profile, metadata] = await Promise.all([
                    window.apiDataService.fetchAvailableBlocks(),
                    window.apiDataService.getUserProfile(),
                    window.apiDataService.fetchBlockMetadata()
                ]);
                
                availableBlocksData = blocks;
                availableBlocksMetadata = metadata;
                const loadedBlockIds = profile.loadedBlocks || [];

                // Renderizar estructura con filtros
                container.innerHTML = `
                    <!-- Filtros de Metadata -->
                    <div class="ab-filters" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px; padding: 15px; background: #0F172A; border-radius: 8px; border: 1px solid #334155;">
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Tipo de Bloque:</label>
                            <select id="ab-filter-tipo" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los tipos</option>
                            </select>
                        </div>
                        
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Nivel:</label>
                            <select id="ab-filter-nivel" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los niveles</option>
                            </select>
                        </div>
                        
                        <div class="ab-filter-group" style="display: flex; flex-direction: column; gap: 5px;">
                            <label style="font-size: 12px; color: #94A3B8; font-weight: 500;">Car√°cter:</label>
                            <select id="ab-filter-caracter" onchange="applyAvailableBlocksFilters()" style="background: #1E293B; border: 1px solid #475569; color: #E2E8F0; padding: 8px 12px; border-radius: 6px; font-size: 14px; outline: none; transition: border-color 0.3s ease;">
                                <option value="">Todos los caracteres</option>
                            </select>
                        </div>
                        
                        <button onclick="clearAvailableBlocksFilters()" style="background: #DC2626; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; height: fit-content; margin-top: auto; transition: background 0.3s ease;">
                            üóëÔ∏è Limpiar Filtros
                        </button>
                    </div>
                    
                    <div id="available-blocks-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 24px;">
                        <!-- Los bloques se cargar√°n aqu√≠ -->
                    </div>
                `;

                // Poblar filtros con metadata
                populateAvailableBlocksFilters(metadata);
                
                // Mostrar todos los bloques inicialmente
                displayAvailableBlocks(blocks, loadedBlockIds);

                // Funci√≥n para manejar acciones de carga/descarga
                window.handleBlockAction = async (blockId, isLoaded) => {
                    try {
                        if (isLoaded) {
                            await window.apiDataService.unloadBlockForUser(blockId);
                        } else {
                            await window.apiDataService.loadBlockForUser(blockId);
                        }
                        // Recargar datos y actualizar la vista manteniendo filtros aplicados
                        const [updatedBlocks, updatedProfile] = await Promise.all([
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);
                        
                        availableBlocksData = updatedBlocks;
                        
                        // Aplicar los filtros actuales a los nuevos datos
                        const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
                        const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
                        const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
                        
                        let filteredBlocks = [...availableBlocksData];
                        
                        if (tipoFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
                        }
                        
                        if (nivelFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
                        }
                        
                        if (caracterFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
                        }
                        
                        await displayAvailableBlocks(filteredBlocks, updatedProfile.loadedBlocks);
                        
                        // üîÑ Refrescar tambi√©n el componente de Bloques Cargados
                        console.log('üîÑ [PJG] Refreshing loaded blocks component after block action...');
                        if (window.bloquesCreados_loaded_blocks_pjg_container && typeof window.bloquesCreados_loaded_blocks_pjg_container.refresh === 'function') {
                            console.log('üîÑ Refreshing bloquesCreados_loaded_blocks_pjg_container...');
                            window.bloquesCreados_loaded_blocks_pjg_container.refresh();
                            console.log('‚úÖ Loaded blocks component refreshed successfully');
                        } else {
                            console.log('‚ÑπÔ∏è Loaded blocks component not available for refresh');
                        }
                        
                    } catch (error) {
                        console.error('Error handling block action:', error);
                        alert('Error al procesar la acci√≥n. Int√©ntalo de nuevo.');
                    }
                };

                // üîÑ Funci√≥n para refrescar solo "Bloques Disponibles" despu√©s de descargar desde "Bloques Cargados"
                window.refreshAvailableBlocksAfterUnload = async () => {
                    console.log('üîÑ [PJG] Refreshing Available Blocks after unload from Loaded Blocks...');
                    try {
                        // Recargar datos de bloques disponibles
                        const [updatedBlocks, updatedProfile] = await Promise.all([
                            window.apiDataService.fetchAvailableBlocks(),
                            window.apiDataService.getUserProfile()
                        ]);
                        
                        availableBlocksData = updatedBlocks;
                        
                        // Aplicar los filtros actuales a los nuevos datos
                        const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
                        const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
                        const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
                        
                        let filteredBlocks = [...availableBlocksData];
                        
                        if (tipoFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
                        }
                        
                        if (nivelFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
                        }
                        
                        if (caracterFilter) {
                            filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
                        }
                        
                        await displayAvailableBlocks(filteredBlocks, updatedProfile.loadedBlocks);
                        console.log('‚úÖ [PJG] Available Blocks refreshed after unload');
                        
                    } catch (error) {
                        console.error('‚ùå Error refreshing available blocks after unload:', error);
                    }
                };

                // Funci√≥n para ver el contenido de bloques disponibles
                window.viewAvailableBlockContent = async (blockId, blockName, isLoaded) => {
                    try {
                        // Crear contenedor para el viewer si no existe
                        let viewerContainer = document.getElementById('available-blocks-content-viewer');
                        if (!viewerContainer) {
                            viewerContainer = document.createElement('div');
                            viewerContainer.id = 'available-blocks-content-viewer';
                            viewerContainer.style.display = 'none';
                            document.getElementById('available-blocks-pjg-container').parentNode.appendChild(viewerContainer);
                        }

                        // Ocultar la lista de bloques disponibles y mostrar el viewer
                        document.getElementById('available-blocks-pjg-container').style.display = 'none';
                        viewerContainer.style.display = 'block';

                        // Crear una instancia temporal del componente BloquesCreados para el viewer
                        if (typeof BloquesCreados !== 'undefined') {
                            viewerContainer.innerHTML = '<div id="temp-available-block-viewer"></div>';
                            
                            const tempViewer = new BloquesCreados('temp-available-block-viewer', 'estudiantes', 'available');
                            tempViewer.initialize().then(() => {
                                // Cargar directamente el contenido del bloque
                                tempViewer.loadBlockContentViewer(blockId, blockName);
                            });

                            // Actualizar el bot√≥n de cierre para volver a la lista de disponibles
                            const checkAndUpdateCloseButton = () => {
                                const closeButton = document.querySelector('#temp-available-block-viewer .bc-btn-close');
                                if (closeButton) {
                                    closeButton.onclick = () => {
                                        viewerContainer.style.display = 'none';
                                        document.getElementById('available-blocks-pjg-container').style.display = 'block';
                                    };
                                } else {
                                    setTimeout(checkAndUpdateCloseButton, 100);
                                }
                            };
                            checkAndUpdateCloseButton();

                        } else {
                            alert('Error: BloquesCreados component not available');
                        }
                    } catch (error) {
                        console.error('Error viewing block content:', error);
                        alert('Error al cargar el contenido del bloque.');
                    }
                };

            } catch (error) {
                console.error('Error loading available blocks:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #EF4444;">
                        <p>Error al cargar los bloques disponibles</p>
                        <button onclick="createAvailableBlocksComponent()" style="margin-top: 10px; padding: 8px 16px; background: #3B82F6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Reintentar
                        </button>
                    </div>
                `;
            }
        };

        // Funci√≥n para poblar los filtros de bloques disponibles
        const populateAvailableBlocksFilters = (metadata) => {
            const tipoSelect = document.getElementById('ab-filter-tipo');
            const nivelSelect = document.getElementById('ab-filter-nivel');
            const caracterSelect = document.getElementById('ab-filter-caracter');
            
            // Poblar filtros de tipo
            if (tipoSelect && metadata.types) {
                metadata.types.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo.id;
                    option.textContent = tipo.name;
                    tipoSelect.appendChild(option);
                });
            }
            
            // Poblar filtros de nivel
            if (nivelSelect && metadata.levels) {
                metadata.levels.forEach(nivel => {
                    const option = document.createElement('option');
                    option.value = nivel.id;
                    option.textContent = nivel.name;
                    nivelSelect.appendChild(option);
                });
            }
            
            // Poblar filtros de car√°cter (estado)
            if (caracterSelect && metadata.states) {
                metadata.states.forEach(estado => {
                    const option = document.createElement('option');
                    option.value = estado.id;
                    option.textContent = estado.name;
                    caracterSelect.appendChild(option);
                });
            }
        };

        // Funci√≥n para mostrar bloques disponibles
        const displayAvailableBlocks = async (blocks, loadedBlockIds) => {
            const grid = document.getElementById('available-blocks-grid');
            if (!grid) return;
            
            // Obtener perfil actualizado si no se proporciona loadedBlockIds
            if (!loadedBlockIds) {
                const profile = await window.apiDataService.getUserProfile();
                loadedBlockIds = profile.loadedBlocks || [];
            }
            
            const blocksHTML = blocks.map(block => {
                const isLoaded = loadedBlockIds.includes(block.id);
                return `
                    <div style="background: #0F172A; border: 1px solid #334155; border-radius: 8px; padding: 24px; transition: all 0.3s ease; min-height: 200px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 16px;">
                            <h3 onclick="viewAvailableBlockContent(${block.id}, '${block.name}', ${isLoaded})" 
                                style="font-size: 16px; font-weight: 600; color: #E0E7FF; margin: 0; flex: 1; line-height: 1.25; cursor: pointer; transition: color 0.3s ease;" 
                                onmouseover="this.style.color='#3B82F6'; this.style.textDecoration='underline';" 
                                onmouseout="this.style.color='#E0E7FF'; this.style.textDecoration='none';">${block.name}</h3>
                            ${isLoaded ? '<span style="font-size: 12px; background: rgba(16, 185, 129, 0.2); color: #10B981; padding: 4px 8px; border-radius: 12px;">Cargado</span>' : ''}
                        </div>
                        
                        <p style="color: #CBD5E1; font-size: 14px; margin-bottom: 12px; line-height: 1.5; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;">
                            ${block.description || 'Sin descripci√≥n'}
                        </p>
                        
                        ${block.metadata ? `
                        <div style="margin-bottom: 12px; font-size: 12px; color: #94A3B8; display: flex; flex-wrap: wrap; gap: 8px 16px; background: #1E293B; padding: 8px; border-radius: 6px;">
                            <span><strong>Tipo:</strong> ${block.metadata.tipo || 'N/A'}</span>
                            <span><strong>Nivel:</strong> ${block.metadata.nivel || 'N/A'}</span>
                            <span><strong>Car√°cter:</strong> ${block.metadata.estado || 'N/A'}</span>
                        </div>
                        ` : ''}
                        
                        <div style="margin-bottom: 16px; font-size: 13px; color: #CBD5E1; display: flex; flex-wrap: wrap; gap: 8px 16px;">
                            <span><strong>Preguntas:</strong> ${block.questionCount || 0}</span>
                            <span><strong>Temas:</strong> ${block.stats?.totalTopics || 0}</span>
                            <span><strong>Usuarios:</strong> ${block.stats?.totalUsers || 0}</span>
                            <span><strong>Autor:</strong> ${block.creatorNickname || 'Usuario'}</span>
                            ${block.stats?.loadedAt ? `<span><strong>Cargado:</strong> ${new Date(block.stats.loadedAt).toLocaleDateString()}</span>` : ''}
                        </div>
                        
                        <button onclick="handleBlockAction(${block.id}, ${isLoaded})" 
                            style="width: 100%; padding: 10px 16px; border-radius: 6px; font-weight: 500; transition: all 0.3s ease; border: none; cursor: pointer; 
                            ${isLoaded 
                                ? 'background: rgba(239, 68, 68, 0.2); color: #EF4444;' 
                                : 'background: #3B82F6; color: white;'
                            }">
                            ${isLoaded ? 'Descargar' : 'Cargar'}
                        </button>
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = blocksHTML;
        };

        // Funci√≥n para aplicar filtros a bloques disponibles
        const applyAvailableBlocksFilters = async () => {
            const tipoFilter = document.getElementById('ab-filter-tipo')?.value;
            const nivelFilter = document.getElementById('ab-filter-nivel')?.value;
            const caracterFilter = document.getElementById('ab-filter-caracter')?.value;
            
            console.log('üîç Applying available blocks filters:', { tipoFilter, nivelFilter, caracterFilter });
            
            if (!availableBlocksData || availableBlocksData.length === 0) {
                console.log('‚ùå No available blocks data for filtering');
                return;
            }
            
            let filteredBlocks = [...availableBlocksData];
            
            // Aplicar filtros
            if (tipoFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.tipo_id == tipoFilter);
            }
            
            if (nivelFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.nivel_id == nivelFilter);
            }
            
            if (caracterFilter) {
                filteredBlocks = filteredBlocks.filter(block => block.estado_id == caracterFilter);
            }
            
            console.log(`‚úÖ Filtered available blocks: ${filteredBlocks.length} from ${availableBlocksData.length} total`);
            
            // Mostrar bloques filtrados
            await displayAvailableBlocks(filteredBlocks);
        };

        // Funci√≥n para limpiar filtros de bloques disponibles
        const clearAvailableBlocksFilters = async () => {
            console.log('üóëÔ∏è Clearing available blocks filters');
            
            document.getElementById('ab-filter-tipo').value = '';
            document.getElementById('ab-filter-nivel').value = '';
            document.getElementById('ab-filter-caracter').value = '';
            
            await displayAvailableBlocks(availableBlocksData);
        };

        // Renderizar componentes espec√≠ficos en pesta√±as despu√©s de que React est√© disponible
        const initializeTabComponents = () => {
            // Inicializar Bloques Cargados con el componente actualizado
            if (document.getElementById('loaded-blocks-pjg-container')) {
                // Esperar a que BloquesCreados est√© disponible
                const initLoadedBlocks = () => {
                    if (typeof BloquesCreados !== 'undefined') {
                        window.bloquesCreados_loaded_blocks_pjg_container = new BloquesCreados('loaded-blocks-pjg-container', 'estudiantes', 'loaded');
                        window.bloquesCreados_loaded_blocks_pjg_container.initialize();
                    } else {
                        setTimeout(initLoadedBlocks, 500);
                    }
                };
                initLoadedBlocks();
            }

            // Inicializar Bloques Disponibles con componente mejorado
            if (document.getElementById('available-blocks-pjg-container')) {
                createAvailableBlocksComponent();
            }

            // Renderizar Juegos Activos COMPLETO en su secci√≥n
            const activeGamesContainer = document.getElementById('active-games-content');
            if (activeGamesContainer) {
                const activeGamesRoot = ReactDOM.createRoot(activeGamesContainer);
                activeGamesRoot.render(
                    React.createElement(LanguageProvider, {}, 
                        React.createElement(UserContext.Provider, { value: { currentUser: JSON.parse(localStorage.getItem('playtest_session') || '{}') } },
                            React.createElement(ActiveGamesComponent)
                        )
                    )
                );
            }

            // Renderizar Historial de Partidas COMPLETO en su pesta√±a
            const gameHistoryContainer = document.getElementById('games-history-content');
            if (gameHistoryContainer) {
                const gameHistoryRoot = ReactDOM.createRoot(gameHistoryContainer);
                gameHistoryRoot.render(
                    React.createElement(LanguageProvider, {},
                        React.createElement(UserContext.Provider, { value: { currentUser: JSON.parse(localStorage.getItem('playtest_session') || '{}') } },
                            React.createElement(TabHistoryComponent)
                        )
                    )
                );
            }

            // Renderizar Rankings Globales en su pesta√±a
            const globalRankingsContainer = document.getElementById('global-rankings-content');
            if (globalRankingsContainer) {
                const globalRankingsRoot = ReactDOM.createRoot(globalRankingsContainer);
                globalRankingsRoot.render(
                    React.createElement(LanguageProvider, {},
                        React.createElement(UserContext.Provider, { value: { currentUser: JSON.parse(localStorage.getItem('playtest_session') || '{}') } },
                            React.createElement(GlobalRankingsComponent)
                        )
                    )
                );
            }
        };

        // Ejecutar cuando el DOM y apiDataService est√©n disponibles
        const waitForApiAndInitialize = () => {
            if (window.apiDataService) {
                initializeTabComponents();
            } else {
                setTimeout(waitForApiAndInitialize, 1000);
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForApiAndInitialize);
        } else {
            waitForApiAndInitialize();
        }

        // Funci√≥n para cambiar entre pesta√±as
        window.switchTab = function(tabName) {
            // Ocultar todos los contenidos de pesta√±as
            const allTabContents = document.querySelectorAll('.tab-content');
            allTabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Desactivar todos los botones de pesta√±a
            const allTabButtons = document.querySelectorAll('.tab-button');
            allTabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Mostrar el contenido de la pesta√±a seleccionada
            const selectedTab = document.getElementById(tabName + '-tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Activar el bot√≥n de la pesta√±a seleccionada
            const selectedButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }

            // Si se abre el tab de Mis Clases, cargar datos
            if (tabName === 'mis-clases') {
                loadMyClasses();
                loadMyGroups();
                loadAssignedBlocks();
            }
        };

        // ==================== MIS CLASES FUNCTIONS ====================

        // Verificar si el usuario tiene clases y mostrar/ocultar el tab
        async function checkUserEnrollments() {
            try {
                const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                if (!session.token || !session.userId) return;

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                const response = await fetch(`${API_URL}/students/my-classes`, {
                    headers: {
                        'Authorization': `Bearer ${session.token}`,
                        'X-Current-Role': 'PJG'
                    }
                });

                if (response.ok) {
                    const classes = await response.json();
                    // La pesta√±a "Mis Clases" ahora siempre est√° visible
                    // para permitir que los estudiantes se inscriban por primera vez
                }
            } catch (error) {
                console.error('Error checking enrollments:', error);
            }
        }

        // Inscribirse en una clase
        async function enrollInClass() {
            const codeInput = document.getElementById('class-code-input');
            const messageEl = document.getElementById('enrollment-message');
            const classCode = codeInput.value.trim().toUpperCase();

            console.log('üéì enrollInClass called with code:', classCode);

            if (!classCode) {
                messageEl.textContent = 'Por favor ingresa un c√≥digo de clase';
                messageEl.style.color = '#EF4444';
                messageEl.style.display = 'block';
                return;
            }

            try {
                // Debug: verificar estado de localStorage
                const rawSession = localStorage.getItem('playtest_session');
                const authToken = localStorage.getItem('playtest_auth_token');
                console.log('üîç Raw session from localStorage:', rawSession);
                console.log('üîç Auth token from localStorage:', authToken ? 'EXISTS' : 'MISSING');

                const session = JSON.parse(rawSession || '{}');
                console.log('üîç Parsed session:', session);
                console.log('üîç session.token:', session.token ? 'EXISTS' : 'MISSING');
                console.log('üîç session.userId:', session.userId);

                if (!session.token || !session.userId) {
                    console.error('‚ùå Missing token or userId. Session:', session);

                    // Si hay token en playtest_auth_token pero no en session, intentar usarlo
                    if (authToken && session.userId) {
                        console.log('‚ö†Ô∏è Token found in separate storage, migrating...');
                        session.token = authToken;
                        localStorage.setItem('playtest_session', JSON.stringify(session));
                        console.log('‚úÖ Session migrated successfully');
                    } else {
                        messageEl.textContent = 'No autenticado. Por favor inicia sesi√≥n.';
                        messageEl.style.color = '#EF4444';
                        messageEl.style.display = 'block';
                        return;
                    }
                }

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                const response = await fetch(`${API_URL}/students/enroll`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${session.token}`,
                        'X-Current-Role': 'PJG',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ class_code: classCode })
                });

                const result = await response.json();
                console.log('üì° Enrollment response:', response.status, result);

                if (response.ok) {
                    messageEl.textContent = `‚úÖ ${result.message || 'Te has inscrito exitosamente en la clase'}`;
                    messageEl.style.color = '#10B981';
                    messageEl.style.display = 'block';
                    codeInput.value = '';

                    // Recargar las clases y mostrar el tab
                    await checkUserEnrollments();
                    await loadMyClasses();
                    await loadAssignedBlocks();
                } else {
                    console.error('‚ùå Enrollment error:', result);
                    messageEl.textContent = result.message || result.error || 'Error al inscribirse en la clase';
                    messageEl.style.color = '#EF4444';
                    messageEl.style.display = 'block';
                }
            } catch (error) {
                console.error('Error enrolling in class:', error);
                messageEl.textContent = 'Error al conectar con el servidor';
                messageEl.style.color = '#EF4444';
                messageEl.style.display = 'block';
            }
        }

        // Cargar las clases del usuario
        async function loadMyClasses() {
            const container = document.getElementById('my-classes-container');

            try {
                const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                if (!session.token || !session.userId) return;

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                container.innerHTML = '<div class="loading">Cargando tus clases...</div>';

                const response = await fetch(`${API_URL}/students/my-classes`, {
                    headers: {
                        'Authorization': `Bearer ${session.token}`,
                        'X-Current-Role': 'PJG'
                    }
                });

                if (!response.ok) throw new Error('Error al cargar clases');

                const data = await response.json();
                const classes = data.classes || [];

                if (!classes || classes.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üè´</div>
                            <h3>No est√°s inscrito en ninguna clase</h3>
                            <p>Ingresa un c√≥digo de clase arriba para empezar</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = classes.map(classItem => `
                    <div class="class-card" style="background: #1B263B; border: 1px solid #415A77; border-radius: 10px; padding: 20px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div>
                                <h3 style="color: #10B981; font-size: 1.3rem; margin-bottom: 5px;">${classItem.class_name}</h3>
                                <p style="color: #778DA9; margin: 0;">${classItem.subject || 'Sin asignatura'}</p>
                                <p style="color: #778DA9; font-size: 0.9rem; margin: 5px 0 0 0;">
                                    Profesor: ${classItem.teacher_name || 'Desconocido'}
                                </p>
                            </div>
                            <span style="background: #374151; color: #10B981; padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; font-family: monospace;">
                                ${classItem.class_code}
                            </span>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #415A77; display: flex; gap: 20px; font-size: 0.9rem; color: #778DA9;">
                            <span>üìö Nivel: ${classItem.grade_level || 'N/A'}</span>
                            <span>üìÖ ${classItem.academic_year || 'N/A'}</span>
                            <span>üìä ${classItem.semester || 'N/A'}</span>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error loading classes:', error);
                container.innerHTML = `
                    <div class="error">
                        <p>Error al cargar las clases: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Cargar los grupos del usuario
        async function loadMyGroups() {
            const container = document.getElementById('my-groups-container');

            try {
                const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                if (!session.token || !session.userId) return;

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                container.innerHTML = '<div class="loading">Cargando tus grupos...</div>';

                const response = await fetch(`${API_URL}/students/my-groups`, {
                    headers: {
                        'Authorization': `Bearer ${session.token}`,
                        'X-Current-Role': 'PJG'
                    }
                });

                if (!response.ok) throw new Error('Error al cargar grupos');

                const data = await response.json();
                const groups = data.groups || [];

                if (!groups || groups.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üë•</div>
                            <h3>No perteneces a ning√∫n grupo</h3>
                            <p>Tu profesor te a√±adir√° a grupos de trabajo cuando sea necesario</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = groups.map(group => `
                    <div class="group-card" style="background: #1B263B; border: 1px solid #415A77; border-radius: 10px; padding: 20px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <h3 style="color: #3B82F6; font-size: 1.3rem; margin-bottom: 5px;">${group.name}</h3>
                                ${group.description ? `<p style="color: #778DA9; margin: 5px 0;">${group.description}</p>` : ''}
                                <p style="color: #778DA9; font-size: 0.9rem; margin: 5px 0 0 0;">
                                    üë®‚Äçüè´ Profesor: ${group.teacher_name || 'Desconocido'}
                                </p>
                            </div>
                            <span style="background: #374151; color: #3B82F6; padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; font-family: monospace;">
                                ${group.access_code || 'N/A'}
                            </span>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #415A77; display: flex; gap: 20px; font-size: 0.9rem; color: #778DA9;">
                            <span>üë• ${group.member_count || 0} miembros</span>
                            <span>üìö ${group.assigned_blocks_count || 0} bloques asignados</span>
                            <span>üìÖ Desde: ${new Date(group.joined_at).toLocaleDateString('es-ES')}</span>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error loading groups:', error);
                container.innerHTML = `
                    <div class="error">
                        <p>Error al cargar los grupos: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Cargar bloques asignados
        async function loadAssignedBlocks() {
            const container = document.getElementById('assigned-blocks-container');

            try {
                const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                if (!session.token || !session.userId) return;

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                container.innerHTML = '<div class="loading">Cargando bloques asignados...</div>';

                // Usar el endpoint correcto de grupos
                const response = await fetch(`${API_URL}/groups/my-assigned-blocks`, {
                    headers: {
                        'Authorization': `Bearer ${session.token}`
                    }
                });

                if (!response.ok) throw new Error('Error al cargar bloques');

                const blocks = await response.json();

                if (!blocks || blocks.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üìù</div>
                            <h3>No tienes bloques asignados</h3>
                            <p>Tus profesores a√∫n no han asignado bloques a tus grupos o individualmente</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = blocks.map(block => `
                    <div class="block-card" style="background: #1B263B; border: 1px solid ${block.assignment_type === 'INDIVIDUAL' ? '#10B981' : '#415A77'}; border-radius: 10px; padding: 20px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                    <h3 style="color: #3B82F6; font-size: 1.2rem; margin: 0;">${block.name}</h3>
                                    <span style="background: ${block.assignment_type === 'INDIVIDUAL' ? '#10B981' : '#3B82F6'}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">
                                        ${block.assignment_type === 'INDIVIDUAL' ? 'üë§ Individual' : 'üë• Grupo'}
                                    </span>
                                </div>
                                <p style="color: #778DA9; margin: 0 0 10px 0;">${block.description || 'Sin descripci√≥n'}</p>
                                <div style="display: flex; flex-wrap: wrap; gap: 12px; font-size: 0.9rem; color: #778DA9;">
                                    ${block.assignment_type === 'GROUP' ? `<span>üë• ${block.group_name}</span>` : '<span>üë§ Asignado solo a ti</span>'}
                                    <span>üë®‚Äçüè´ ${block.assigned_by_nickname || 'Profesor'}</span>
                                    ${block.notes ? `<span>üí¨ ${block.notes}</span>` : ''}
                                </div>
                            </div>
                            <button class="btn btn-primary btn-sm" onclick="loadBlock(${block.id})" style="background: #10B981; white-space: nowrap;">
                                Cargar Bloque
                            </button>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            ${block.due_date ? `
                                <div style="flex: 1; padding: 8px; background: #374151; border-radius: 6px; font-size: 0.85rem; color: #E0E1DD;">
                                    üìÖ Fecha l√≠mite: ${new Date(block.due_date).toLocaleDateString('es-ES')}
                                </div>
                            ` : ''}
                            <div style="flex: 1; padding: 8px; background: #0D1B2A; border-radius: 6px; font-size: 0.85rem; color: #778DA9;">
                                üïê Asignado: ${new Date(block.assigned_at).toLocaleDateString('es-ES')}
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error loading assigned blocks:', error);
                container.innerHTML = `
                    <div class="error">
                        <p>Error al cargar bloques asignados: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Funci√≥n para cargar un bloque asignado
        async function loadBlock(blockId) {
            try {
                const session = JSON.parse(localStorage.getItem('playtest_session') || '{}');
                if (!session.token || !session.userId) {
                    alert('No autenticado. Por favor inicia sesi√≥n.');
                    return;
                }

                const API_URL = window.location.hostname.includes('onrender.com')
                    ? 'https://playtest-backend.onrender.com/api'
                    : 'http://localhost:3001/api';

                const response = await fetch(`${API_URL}/blocks/${blockId}/load`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${session.token}`,
                        'X-Current-Role': 'PJG',
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    alert('‚úÖ Bloque cargado exitosamente');
                    // Recargar la lista de bloques cargados si existe
                    if (window.bloquesCreados_loaded_blocks_pjg_container && typeof window.bloquesCreados_loaded_blocks_pjg_container.refresh === 'function') {
                        window.bloquesCreados_loaded_blocks_pjg_container.refresh();
                    }
                } else {
                    const error = await response.json();
                    alert('Error: ' + (error.error || 'No se pudo cargar el bloque'));
                }
            } catch (error) {
                console.error('Error loading block:', error);
                alert('Error al cargar el bloque: ' + error.message);
            }
        }

        // Inicializar verificaci√≥n de clases al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', () => {
            checkUserEnrollments();
        });
    </script>

    <!-- Los modales se cargan din√°micamente con el header-component (SIN modales de Explicaci√≥n del Juego) -->
</body>
</html>